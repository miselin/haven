foreign "m" {
    fn fabsf(float x) -> float;
}

foreign "c" {
    fn printf(str format, *) -> i32;
}

type Result = {
    float eigenvalue;
    fvec3 eigenvector;
};

// pass-by-ref is unnecessary here, but showing the syntax anyway
fn vec-mul-mat(fvec3 cell v, mat3x3 m) -> fvec3 {
    v * m
}

fn vec-dot(fvec3 a, fvec3 b) -> float {
    let mult = a * b;
    mult.x + mult.y + mult.z
}

impure fn vec-norm(fvec3 v) -> fvec3 {
    let denom = 1.0 / sqrtf(vec-dot(v, v));
    v * denom
}

impure fn power_iter(mat3x3 m) -> Result {
    // fvec3 inferred from vector initializer
    // mutable values allowing reassignment later, type `fvec3 cell` inferred
    let eigenvector = cell <1.0, 1.0, 1.0>;
    let eigenvalue = cell 0.0;

    while 1 {
        // rvalue of `T cell` consumes the referenced value directly - pass by value
        // use & to pass a `T cell` directly e.g. &eigenvector == `fvec3 cell` - pass by reference
        // function needs to take `T cell` explicitly to use &...
        let v = vec-mul-mat(&eigenvector, m);
        let new-eigenvalue = vec-dot(v, eigenvector);

        if fabsf(new-eigenvalue - eigenvalue) < 0.000001 {
            eigenvalue := new-eigenvalue;
            break;
        };

        // update of the mutable cell's value via := assignment
        eigenvalue := new-eigenvalue;
        eigenvector := vec-norm(v);
    };

    // fn return type provides the context to understand the initializer
    { eigenvalue, eigenvector }
}

pub impure fn main() -> i32 {
    // mat3x3 inferred from matrix initializer
    let m = <<2.0, -1.0, 0.0>,
             <-1.0, 2.0, -1.0>,
             <0.0, -1.0, 2.0>>;

    let result = power_iter(m);

    printf("eigenvalue: %f\n", result.eigenvalue);

    let v = result.eigenvector;
    printf("eigenvalues: %f %f %f\n", v.x, v.y, v.z);
    0
}
