foreign "m" {
    fn fabsf(float x) -> float;
    fn sqrtf(float x) -> float;
}

foreign "c" {
    fn printf(str format, *) -> i32;
}

type Result = struct {
    float eigenvalue;
    fvec3 eigenvector;
};

// Demonstrating syntax - usually no need to pass fvec as a box
impure fn vec-mul-mat(fvec3 ^v, mat3x3 m) -> fvec3 {
    (unbox v) * m
}

fn vec-dot(fvec3 a, fvec3 b) -> float {
    let mult = a * b;
    mult.x + mult.y + mult.z
}

impure fn vec-norm(fvec3 v) -> fvec3 {
    let denom = 1.0 / sqrtf(vec-dot(v, v));
    v * denom
}

impure fn power_iter(mat3x3 m) -> Result {
    // fvec3 inferred from vector initializer
    let eigenvector = box <1.0, 1.0, 1.0>;
    let eigenvalue = box 0.0;

    while 1 {
        let v = vec-mul-mat(eigenvector, m);
        let new-eigenvalue = vec-dot(v, unbox eigenvector);

        if fabsf(new-eigenvalue - (unbox eigenvalue)) < 0.000001 {
            eigenvalue := new-eigenvalue;
            break;
        };

        // update of the mutable cell's value via := assignment
        eigenvalue := new-eigenvalue;
        eigenvector := vec-norm(v);
    };

    // fn return type provides the context to understand the initializer
    { unbox eigenvalue, unbox eigenvector }
}

pub impure fn main() -> i32 {
    // mat3x3 inferred from matrix initializer
    let m = <<2.0, -1.0, 0.0>,
             <-1.0, 2.0, -1.0>,
             <0.0, -1.0, 2.0>>;

    let result = power_iter(m);

    printf("eigenvalue: %f\n", result.eigenvalue);

    let v = result.eigenvector;
    printf("eigenvalues: %f %f %f\n", v.x, v.y, v.z);
    0
}
