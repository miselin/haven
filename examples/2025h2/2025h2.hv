foreign "m" {
    fn fabsf(float x) -> float;
}

foreign "c" {
    fn printf(str format, *) -> i32;
}

type Result = {
    float eigenvalue;
    fvec3 eigenvector;
};

fn vec-mul-mat(fvec3 v, mat3x3 m) -> fvec3 {
    v * m
}

fn vec-dot(fvec3 a, fvec3 b) -> float {
    let mult = a * b;
    mult.x + mult.y + mult.z
}

impure fn vec-norm(fvec3 v) -> fvec3 {
    let denom = 1.0 / sqrtf(vec-dot(v, v));
    v * denom
}

impure fn power_iter(mat3x3 m) -> Result {
    // fvec3 inferred from vector initializer
    // mutable value allowing reassignment later
    let eigenvector = mutable <1.0, 1.0, 1.0>;
    let eigenvalue = mutable 0.0;

    while 1 {
        let v = vec-mul-mat(eigenvector, m);
        let new-eigenvalue = vec-dot(v, eigenvector);

        if fabsf(new-eigenvalue - eigenvalue) < 0.000001 {
            eigenvalue := new-eigenvalue;
            break;
        };

        eigenvalue := new-eigenvalue;
        eigenvector := vec-norm(v);
    };

    { eigenvalue, eigenvector }
}

pub impure fn main() -> i32 {
    // mat3x3 inferred from matrix initializer
    let m = <<2.0, -1.0, 0.0>,
             <-1.0, 2.0, -1.0>,
             <0.0, -1.0, 2.0>>;

    let result = power_iter(m);

    printf("eigenvalue: %f\n", result.eigenvalue);

    let v = result.eigenvector;
    printf("eigenvalues: %f %f %f\n", v.x, v.y, v.z);
    0
}
