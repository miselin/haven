cimport "stdlib.h";

pub impure fn u64 strlen(i8 *s);
pub impure fn i8* strcpy(i8 *dest, i8 *src);
pub impure fn i32 strcmp(i8 *s1, i8 *s2);

type KVNode = struct {
    i8 *key;
    void *value;
    KVNode *next;
};

type KV = struct {
    KVNode *head;
};

type KVIterator = struct {
    KVNode *node;
};

pub impure fn KV *haven_new_kv() {
    let KV *heap_kv = malloc(8);
    let kv = struct KV { nil };
    store heap_kv kv;
    heap_kv
}

pub impure fn void haven_kv_insert(KV *kv, i8 *key, void *value) {
    if strlen(key) == 0 {
        ret;
    };

    let KV *heap_new_node = malloc(32);
    let new_node = struct KVNode { as i8* malloc(strlen(key) + 1), value, nil };
    strcpy(new_node.key, key);
    store heap_new_node new_node;

    let mut node = kv.head;
    if node == nil {
        let new_kv = struct KV { heap_new_node };
        store kv new_kv;
        ret;
    };

    while node.next != nil {
        node = node.next;
    };

    // this is such awful ergonomics, need to fix this language
    let node_ = struct KVNode { node.key, node.value, heap_new_node };
    store node node_;
}

pub impure fn i8* haven_kv_lookup(KV *kv, i8 *key) {
    let mut node = kv.head;
    while node != nil {
        if strcmp(node.key, key) == 0 {
            ret node.value;
        };

        node = node.next;
    };

    as i8* 0
}

pub impure fn void haven_kv_delete(KV *kv, i8 *key) {
    let mut cur = kv.head;
    let mut KVNode *prev = nil;
    while cur != nil {
        if strcmp(cur.key, key) == 0 {
            if prev == nil {
                let new_kv = struct KV { cur.next };
                store kv new_kv;
            } else {
                let node_ = struct KVNode { prev.key, prev.value, cur.next };
                store prev node_;
            };

            free(cur.key);
            free(cur);
            break;
        };

        prev = cur;
        cur = cur.next;
    };
}

pub impure fn void haven_kv_destroy(KV *kv) {
    let mut node = kv.head;
    while node != nil {
        let next = node.next;
        free(node.key);
        free(node);
        node = next;
    };

    free(kv);
}

pub impure fn KVNode* haven_kv_iter(KV *kv) {
    kv.head
}

pub impure fn i8 *haven_kv_next(KVIterator *kviter) {
    let mut node = kviter.node;
    if node == nil {
        as i8* 0
    } else {
        let new_kviter = struct KVIterator { node.next };
        store kviter new_kviter;

        node.value
    }
}

pub impure fn i32 haven_kv_end(KVNode *iter_node) {
    if iter_node == nil { 1 } else { 0 }
}
