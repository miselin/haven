cimport "stdlib.h";
import "kv.hv";

type Scope = struct {
    KV *values;
    Scope *parent;
};

pub impure fn scope_iter(Scope *scope) -> KVNode*;
pub impure fn scope_next(mut KVIterator *iter_node) -> i8*;
pub impure fn scope_end(KVNode *iter_node) -> i32;

pub impure fn enter_scope(Scope *parent) -> Scope* {
    let mut result = as Scope* malloc(as u64 size<Scope>);
    result->values = new_kv();
    result->parent = parent;
    result
}

pub impure fn exit_scope(Scope *scope) -> Scope* {
    let mut parent = scope->parent;

    let iter_node = scope_iter(scope);
    while !scope_end(iter_node) {
        let node = scope_next(ref iter_node);
        free(node);
    };

    destroy_kv(scope->values);

    free(scope);
    parent
}

pub impure fn scope_insert(Scope *scope, i8 *key, void *value) -> void {
    kv_delete(scope->values, key);
    kv_insert(scope->values, key, value);
}

pub impure fn scope_lookup(Scope *scope, i8 *key, i32 recurse) -> void* {
    let mut result = kv_lookup(scope->values, key);
    if result != nil {
        result
    } else if recurse == 1 && scope->parent != nil {
        scope_lookup(scope->parent, key, 1)
    } else {
        nil
    }
}

pub impure fn scope_iter(Scope *scope) -> KVNode* {
    kv_iter(scope->values)
}

pub impure fn scope_next(mut KVIterator *iter_node) -> i8* {
    kv_next(iter_node)
}

pub impure fn scope_end(KVNode *iter_node) -> i32 {
    kv_end(iter_node)
}

pub impure fn scope_parent(Scope *scope) -> Scope* {
    scope->parent
}
