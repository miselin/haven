#include "typecheck.h"

#include <ctype.h>
#include <malloc.h>
#include <stdarg.h>
#include <stdlib.h>
#include <string.h>

#include "ast.h"
#include "compiler.h"
#include "kv.h"
#include "scope.h"
#include "types.h"
#include "utility.h"

struct scope_entry {
  struct ast_vdecl *vdecl;
  struct ast_fdecl *fdecl;
};

struct alias_entry {
  struct ast_ty ty;
};

struct typecheck {
  struct ast_program *ast;

  struct scope *scope;

  int errors;

  struct kv *aliases;

  struct ast_ty void_type;
  struct ast_ty error_type;
  struct ast_ty tbd_type;

  struct compiler *compiler;
};

int typecheck_verify_ast(struct ast_program *ast);
int typecheck_implicit_ast(struct ast_program *ast);

static void typecheck_ast(struct typecheck *typecheck, struct ast_program *ast);
static void typecheck_toplevel(struct typecheck *typecheck, struct ast_toplevel *ast);
static struct ast_ty *typecheck_block(struct typecheck *typecheck, struct ast_block *ast);
static struct ast_ty *typecheck_stmt(struct typecheck *typecheck, struct ast_stmt *ast);
static struct ast_ty *typecheck_expr(struct typecheck *typecheck, struct ast_expr *ast)
    __attribute__((warn_unused_result));
// Allow TBD types to be generated by the expression
static struct ast_ty *typecheck_expr_with_tbds(struct typecheck *typecheck, struct ast_expr *ast);
static struct ast_ty *typecheck_expr_inner(struct typecheck *typecheck, struct ast_expr *ast);

static struct ast_ty resolve_type(struct typecheck *typecheck, struct ast_ty *ty);

static void typecheck_struct_decl(struct typecheck *typecheck, struct ast_ty *decl);

static int binary_mismatch_ok(int op, struct ast_ty *lhs, struct ast_ty *rhs);

static int deref_to_index(const char *deref);

// If allowed, makes from and to the same type using implicit conversion rules
// Does nothing if implicit conversion is disallowed or irrelevant.
int maybe_implicitly_convert(struct ast_ty *from, struct ast_ty *to);

__attribute__((format(printf, 3, 4))) static void typecheck_diag_expr(struct typecheck *typecheck,
                                                                      struct ast_expr *expr,
                                                                      const char *msg, ...) {
  char msgbuf[1024];

  va_list args;
  va_start(args, msg);
  vsprintf(msgbuf, msg, args);
  va_end(args);

  compiler_diag(typecheck->compiler, DiagError, "%s:%zu:%zu: %s", expr->loc.file, expr->loc.line,
                expr->loc.column, msgbuf);

  ++typecheck->errors;
}

struct typecheck *new_typecheck(struct ast_program *ast, struct compiler *compiler) {
  struct typecheck *result = calloc(1, sizeof(struct typecheck));
  result->ast = ast;
  result->scope = enter_scope(NULL);
  result->aliases = new_kv();
  result->error_type = type_error();
  result->void_type = type_void();
  result->tbd_type = type_tbd();
  result->compiler = compiler;
  return result;
}

int typecheck_run(struct typecheck *typecheck) {
  typecheck_ast(typecheck, typecheck->ast);
  if (typecheck->errors) {
    return typecheck->errors;
  }
  if (typecheck_verify_ast(typecheck->ast) < 0) {
    return 1;
  }
  int rc = 0;
  while (1) {
    rc = typecheck_implicit_ast(typecheck->ast);
    if (rc < 0) {
      return 1;
    }

    if (rc == 0) {
      break;
    }
  }
  return 0;
}

void destroy_typecheck(struct typecheck *typecheck) {
  exit_scope(typecheck->scope);
  void *iter = kv_iter(typecheck->aliases);
  while (!kv_end(iter)) {
    struct alias_entry *entry = kv_next(&iter);
    free(entry);
  }
  destroy_kv(typecheck->aliases);
  free(typecheck);
}

static void typecheck_ast(struct typecheck *typecheck, struct ast_program *ast) {
  struct ast_toplevel *decl = ast->decls;
  while (decl) {
    typecheck_toplevel(typecheck, decl);
    decl = decl->next;
  }
}

static void typecheck_toplevel(struct typecheck *typecheck, struct ast_toplevel *ast) {
  if (ast->type == AST_DECL_TYPE_FDECL) {
    ast->fdecl.retty = resolve_type(typecheck, &ast->fdecl.retty);
    if (type_is_error(&ast->fdecl.retty) || type_is_tbd(&ast->fdecl.retty)) {
      fprintf(stderr, "function %s has unresolved return type\n",
              ast->fdecl.ident.value.identv.ident);
      ++typecheck->errors;
      return;
    }

    struct scope_entry *existing =
        scope_lookup(typecheck->scope, ast->fdecl.ident.value.identv.ident, 1);

    struct scope_entry *entry = calloc(1, sizeof(struct scope_entry));
    entry->fdecl = &ast->fdecl;

    scope_insert(typecheck->scope, ast->fdecl.ident.value.identv.ident, entry);

    if (existing) {
      if (entry->fdecl->flags != existing->fdecl->flags) {
        fprintf(stderr, "function %s redeclared with different flags\n",
                ast->fdecl.ident.value.identv.ident);
        ++typecheck->errors;
      }

      if (!same_type(&entry->fdecl->retty, &existing->fdecl->retty)) {
        char tystr[256], existingstr[256];
        type_name_into(&entry->fdecl->retty, tystr, 256);
        type_name_into(&existing->fdecl->retty, existingstr, 256);

        fprintf(stderr, "function %s redeclared with different return type %s, expected %s\n",
                ast->fdecl.ident.value.identv.ident, tystr, existingstr);
        ++typecheck->errors;
      }

      if (entry->fdecl->num_params != existing->fdecl->num_params) {
        fprintf(stderr,
                "function %s redeclared with different number of parameters %zu, expected %zu\n",
                ast->fdecl.ident.value.identv.ident, entry->fdecl->num_params,
                existing->fdecl->num_params);
        ++typecheck->errors;
      }

      for (size_t i = 0; i < entry->fdecl->num_params; ++i) {
        entry->fdecl->params[i]->ty = resolve_type(typecheck, &entry->fdecl->params[i]->ty);

        if (!same_type(&entry->fdecl->params[i]->ty, &existing->fdecl->params[i]->ty)) {
          char tystr[256], existingstr[256];
          type_name_into(&entry->fdecl->params[i]->ty, tystr, 256);
          type_name_into(&existing->fdecl->params[i]->ty, existingstr, 256);

          fprintf(stderr, "function %s parameter %zu has type %s, expected %s\n",
                  ast->fdecl.ident.value.identv.ident, i, tystr, existingstr);
          ++typecheck->errors;
        }
      }

      // done with the old entry, new definition is compatible
      free(existing);
    }

    if (ast->fdecl.body) {
      typecheck->scope = enter_scope(typecheck->scope);

      // declare the parameters in the function scope
      for (size_t i = 0; i < ast->fdecl.num_params; i++) {
        struct scope_entry *param_entry = calloc(1, sizeof(struct scope_entry));
        param_entry->vdecl = ast->fdecl.params[i];
        scope_insert(typecheck->scope, ast->fdecl.params[i]->ident.value.identv.ident, param_entry);
      }

      struct ast_ty *result = typecheck_block(typecheck, ast->fdecl.body);

      typecheck->scope = exit_scope(typecheck->scope);

      if (!result) {
        return;
      }

      maybe_implicitly_convert(result, &ast->fdecl.retty);

      if (!same_type(result, &ast->fdecl.retty)) {
        char resultstr[256], tystr[256];
        type_name_into(result, resultstr, 256);
        type_name_into(&ast->fdecl.retty, tystr, 256);

        fprintf(stderr, "function %s returns %s, expected %s\n",
                ast->fdecl.ident.value.identv.ident, resultstr, tystr);
        ++typecheck->errors;
        return;
      }
    }
  } else if (ast->type == AST_DECL_TYPE_VDECL) {
    struct ast_ty new_type = resolve_type(typecheck, &ast->vdecl.ty);
    if (type_is_error(&new_type) || type_is_tbd(&new_type)) {
      fprintf(stderr, "variable %s has unresolved type\n", ast->vdecl.ident.value.identv.ident);
      ++typecheck->errors;
      return;
    }

    // resolve creates a copy, clean up old type
    free_ty(&ast->vdecl.ty, 0);
    ast->vdecl.ty = new_type;

    if (ast->vdecl.init_expr) {
      struct scope_entry *existing =
          scope_lookup(typecheck->scope, ast->vdecl.ident.value.identv.ident, 0);
      if (existing) {
        fprintf(stderr, "typecheck: multiple definitions of variable %s\n",
                ast->vdecl.ident.value.identv.ident);
        ++typecheck->errors;
        return;
      }

      struct scope_entry *entry = calloc(1, sizeof(struct scope_entry));
      entry->vdecl = &ast->vdecl;

      // insert before checking the initializer to allow recursive references
      scope_insert(typecheck->scope, ast->vdecl.ident.value.identv.ident, entry);

      struct ast_ty *result = typecheck_expr(typecheck, ast->vdecl.init_expr);
      if (!result) {
        return;
      }

      maybe_implicitly_convert(result, &ast->vdecl.ty);

      if (!same_type(result, &ast->vdecl.ty)) {
        char resultstr[256], tystr[256];
        type_name_into(result, resultstr, 256);
        type_name_into(&ast->vdecl.ty, tystr, 256);

        typecheck_diag_expr(typecheck, ast->vdecl.init_expr,
                            "variable %s initializer has type %s, expected %s\n",
                            ast->vdecl.ident.value.identv.ident, resultstr, tystr);
        ++typecheck->errors;
        return;
      }
    }
  } else if (ast->type == AST_DECL_TYPE_TYDECL) {
    struct alias_entry *entry = calloc(1, sizeof(struct alias_entry));
    entry->ty = ast->tydecl.ty;
    kv_insert(typecheck->aliases, ast->tydecl.ident.value.identv.ident, entry);

    if (ast->tydecl.ty.ty == AST_TYPE_STRUCT) {
      typecheck_struct_decl(typecheck, &ast->tydecl.ty);
    }
  }
}

static void typecheck_struct_decl(struct typecheck *typecheck, struct ast_ty *decl) {
  UNUSED(typecheck);
  UNUSED(decl);

  // TODO: causes infinite recursive loop on recursive struct definitions

  struct ast_struct_field *field = decl->structty.fields;
  while (field) {
    // TODO: check for recursive definition, ensure it's a pointer if so, or it's not representable
    *field->ty = resolve_type(typecheck, field->ty);
    field = field->next;
  }
}

static struct ast_ty *typecheck_block(struct typecheck *typecheck, struct ast_block *ast) {
  typecheck->scope = enter_scope(typecheck->scope);

  struct ast_stmt *stmt = ast->stmt;
  struct ast_ty *last_ty = &typecheck->void_type;

  while (stmt) {
    struct ast_ty *ty = typecheck_stmt(typecheck, stmt);
    if (!ty) {
      return NULL;
    }

    if (!stmt->next) {
      last_ty = ty;
    }
    stmt = stmt->next;
  }

  typecheck->scope = exit_scope(typecheck->scope);
  return last_ty;
}

static struct ast_ty *typecheck_stmt(struct typecheck *typecheck, struct ast_stmt *ast) {
  switch (ast->type) {
    case AST_STMT_TYPE_EXPR:
      return typecheck_expr(typecheck, ast->expr);

    case AST_STMT_TYPE_LET: {
      struct scope_entry *entry = calloc(1, sizeof(struct scope_entry));
      entry->vdecl = &ast->let;

      // insert before checking the initializer to allow recursive references
      scope_insert(typecheck->scope, ast->let.ident.value.identv.ident, entry);

      struct ast_ty *init_ty = typecheck_expr(typecheck, ast->let.init_expr);
      if (!init_ty) {
        return NULL;
      }

      if (type_is_tbd(&ast->let.ty)) {
        // inferred type
        ast->let.ty = *init_ty;
        ast->let.ty.flags &= ~TYPE_FLAG_CONSTANT;  // no longer a constant
      }

      maybe_implicitly_convert(init_ty, &ast->let.ty);

      if (!same_type(&ast->let.ty, init_ty)) {
        char tystr[256], initstr[256];
        type_name_into(&ast->let.ty, tystr, 256);
        type_name_into(init_ty, initstr, 256);

        typecheck_diag_expr(typecheck, ast->let.init_expr,
                            "let %s initializer has type %s, expected %s\n",
                            ast->let.ident.value.identv.ident, initstr, tystr);
        ++typecheck->errors;
      }
    } break;

    case AST_STMT_TYPE_ITER: {
      struct ast_ty *start = typecheck_expr(typecheck, ast->iter.range.start);
      struct ast_ty *end = typecheck_expr(typecheck, ast->iter.range.end);
      struct ast_ty *step, step_ty;
      if (ast->iter.range.step) {
        step = typecheck_expr(typecheck, ast->iter.range.step);
      } else {
        step_ty.ty = AST_TYPE_INTEGER;
        step_ty.integer.is_signed = 1;
        step_ty.integer.width = 32;
        step = &step_ty;
      }

      if (!same_type(start, end)) {
        char startstr[256], endstr[256];
        type_name_into(start, startstr, 256);
        type_name_into(end, endstr, 256);

        fprintf(stderr, "iter range start has type %s, end has type %s\n", startstr, endstr);
        ++typecheck->errors;
      }

      if (ast->iter.range.step && !same_type(start, step)) {
        char startstr[256], stepstr[256];
        type_name_into(start, startstr, 256);
        type_name_into(step, stepstr, 256);

        fprintf(stderr, "iter range start has type %s, step has type %s\n", startstr, stepstr);
        ++typecheck->errors;
      }

      struct ast_vdecl *index = calloc(1, sizeof(struct ast_vdecl));

      struct scope_entry *entry = calloc(1, sizeof(struct scope_entry));
      entry->vdecl = index;
      entry->vdecl->ident = ast->iter.index.ident;
      entry->vdecl->ty = *start;
      ast->iter.index_vdecl = entry->vdecl;

      // new scope for the loop variable
      typecheck->scope = enter_scope(typecheck->scope);

      // insert before checking the initializer to allow recursive references
      scope_insert(typecheck->scope, ast->iter.index.ident.value.identv.ident, entry);

      typecheck_block(typecheck, &ast->iter.block);

      typecheck->scope = exit_scope(typecheck->scope);
    } break;

    case AST_STMT_TYPE_STORE: {
      struct ast_ty *lhs = typecheck_expr(typecheck, ast->store.lhs);
      struct ast_ty *rhs = typecheck_expr(typecheck, ast->store.rhs);

      if (!lhs || !rhs) {
        return NULL;
      }

      if (!(lhs->flags & TYPE_FLAG_PTR)) {
        fprintf(stderr, "store lhs is not a pointer\n");
        ++typecheck->errors;
      }

      // for type checks, remove the pointer flag
      if (!same_type_masked(lhs, rhs, ~TYPE_FLAG_PTR)) {
        char lhsstr[256], rhsstr[256];
        type_name_into(lhs, lhsstr, 256);
        type_name_into(rhs, rhsstr, 256);

        fprintf(stderr, "store lhs has type %s, rhs has type %s\n", lhsstr, rhsstr);
        ++typecheck->errors;
      }

    } break;

    case AST_STMT_TYPE_RETURN: {
      // TODO: make sure this expr type matches the function's return type
      return typecheck_expr(typecheck, ast->expr);
    } break;

    case AST_STMT_TYPE_DEFER: {
      if (!typecheck_expr(typecheck, ast->expr)) {
        return NULL;
      }
      // expression type is irrelevant; defer is a void statement
    } break;

    default:
      typecheck_diag_expr(typecheck, NULL, "typecheck: unhandled statement type %d\n", ast->type);
  }

  // statements that aren't expressions do not have types (their expressions do)
  return &typecheck->void_type;
}

static struct ast_ty *typecheck_expr(struct typecheck *typecheck, struct ast_expr *ast) {
  struct ast_ty *ty = typecheck_expr_with_tbds(typecheck, ast);
  if (!ty) {
    return ty;
  }

  if (type_is_tbd(ty)) {
    typecheck_diag_expr(typecheck, ast,
                        "type is not yet resolved, but this context requires a resolved type\n");
    return NULL;
  }

  return ty;
}

static struct ast_ty *typecheck_expr_with_tbds(struct typecheck *typecheck, struct ast_expr *ast) {
  struct ast_ty *ty = typecheck_expr_inner(typecheck, ast);
  if (!ty) {
    return ty;
  }

  if (type_is_error(ty)) {
    typecheck_diag_expr(typecheck, ast, "type failed to resolve\n");
    return NULL;
  }

  return ty;
}

static struct ast_ty *typecheck_expr_inner(struct typecheck *typecheck, struct ast_expr *ast) {
  switch (ast->type) {
    case AST_EXPR_TYPE_CONSTANT: {
      struct ast_ty new_ty = resolve_type(typecheck, &ast->ty);
      free_ty(&ast->ty, 0);
      ast->ty = new_ty;

      switch (ast->ty.ty) {
        case AST_TYPE_FVEC:
        case AST_TYPE_ARRAY: {
          struct ast_expr_list *node = ast->list;
          while (node) {
            struct ast_ty *ty = typecheck_expr(typecheck, node->expr);
            if (!ty) {
              return NULL;
            }

            if (ast->ty.ty == AST_TYPE_ARRAY) {
              maybe_implicitly_convert(ty, ast->ty.array.element_ty);
            }

            node = node->next;
          }

        } break;
        default:
          break;
      }
      return &ast->ty;
    } break;

    case AST_EXPR_TYPE_STRUCT_INIT: {
      struct ast_ty resolved = resolve_type(typecheck, ast->ty.array.element_ty);

      // TODO: check each field initializer against the struct type
      struct ast_struct_field *field = resolved.structty.fields;
      struct ast_expr_list *node = ast->list;
      while (node) {
        struct ast_ty *expr_ty = typecheck_expr(typecheck, node->expr);
        if (!expr_ty) {
          return NULL;
        }

        if (type_is_nil(expr_ty)) {
          // swap expr type for the real underlying type for checking + codegen
          // the expr is a nil expression, so this is safe to do.
          *expr_ty = *field->ty;
        }

        // TODO: fuzzer found field to be null here, the AST doesn't make sense to cause that
        // either way though, we should check that both node & field are non-null
        if (!field) {
          fprintf(stderr, "struct initializer has more fields than the struct type\n");
          ++typecheck->errors;
          break;
        }

        if (!field->ty) {
          fprintf(stderr, "struct initializer field %s inexplicably has no type\n", field->name);
          ++typecheck->errors;
        }

        if (!same_type(expr_ty, field->ty)) {
          char exprty[256];
          char fieldty[256];
          type_name_into(expr_ty, exprty, 256);
          type_name_into(field->ty, fieldty, 256);

          fprintf(stderr, "struct initializer field %s has type %s, expected %s\n", field->name,
                  exprty, fieldty);
          ++typecheck->errors;
        }

        node = node->next;
        field = field->next;
      }

      *ast->ty.array.element_ty = resolved;
      return ast->ty.array.element_ty;
    } break;

    case AST_EXPR_TYPE_VARIABLE: {
      struct scope_entry *entry =
          scope_lookup(typecheck->scope, ast->variable.ident.value.identv.ident, 1);
      if (!entry || !entry->vdecl) {
        fprintf(stderr, "%s not found or not a variable\n", ast->variable.ident.value.identv.ident);
        ++typecheck->errors;
        return &typecheck->error_type;
      }
      ast->ty = resolve_type(typecheck, &entry->vdecl->ty);
      return &ast->ty;
    } break;

    case AST_EXPR_TYPE_ARRAY_INDEX: {
      const char *ident = ast->array_index.ident.value.identv.ident;
      struct scope_entry *entry = scope_lookup(typecheck->scope, ident, 1);
      if (!entry || !entry->vdecl) {
        fprintf(stderr, "%s not found or not a variable\n", ident);
        ++typecheck->errors;
        return &typecheck->error_type;
      }

      if (entry->vdecl->ty.ty != AST_TYPE_ARRAY) {
        char tystr[256];
        type_name_into(&entry->vdecl->ty, tystr, 256);

        fprintf(stderr, "array index %s has type %s, expected an array type\n", ident, tystr);
        ++typecheck->errors;
        return &typecheck->error_type;
      }

      ast->ty = resolve_type(typecheck, entry->vdecl->ty.array.element_ty);
      return &ast->ty;
    } break;

    case AST_EXPR_TYPE_BINARY: {
      struct ast_ty *lhs = typecheck_expr(typecheck, ast->binary.lhs);
      struct ast_ty *rhs = typecheck_expr(typecheck, ast->binary.rhs);

      if (!lhs || !rhs) {
        return NULL;
      }

      maybe_implicitly_convert(lhs, rhs);
      maybe_implicitly_convert(rhs, lhs);

      if (!same_type(lhs, rhs) && !binary_mismatch_ok(ast->binary.op, lhs, rhs)) {
        char lhsstr[256], rhsstr[256];
        type_name_into(lhs, lhsstr, 256);
        type_name_into(rhs, rhsstr, 256);

        fprintf(stderr, "binary op %s has mismatching lhs type %s, rhs type %s\n",
                ast_binary_op_to_str(ast->binary.op), lhsstr, rhsstr);
        ++typecheck->errors;
        return &typecheck->error_type;
      }

      if (ast_binary_op_conditional(ast->binary.op) || ast_binary_op_logical(ast->binary.op)) {
        // conditionals & logicals both emit 1-bit booleans
        // don't set signed flag - booleans need to zero-extend in conversions, not sign-extend
        ast->ty.ty = AST_TYPE_INTEGER;
        ast->ty.integer.is_signed = 0;
        ast->ty.integer.width = 1;
        return &ast->ty;
      }

      ast->ty = resolve_type(typecheck, lhs);
      return &ast->ty;
    } break;

    case AST_EXPR_TYPE_LOGICAL: {
      struct ast_ty *lhs = typecheck_expr(typecheck, ast->logical.lhs);
      struct ast_ty *rhs = typecheck_expr(typecheck, ast->logical.rhs);

      if (!lhs || !rhs) {
        return NULL;
      }

      // TODO: consider widening/narrowing to make type of lhs == rhs

      if (!same_type(lhs, rhs)) {
        char lhsstr[256], rhsstr[256];
        type_name_into(lhs, lhsstr, 256);
        type_name_into(rhs, rhsstr, 256);

        fprintf(stderr, "logical op %d has mismatching lhs type %s, rhs type %s\n", ast->logical.op,
                lhsstr, rhsstr);
        ++typecheck->errors;
        return &typecheck->error_type;
      }

      // return type of this operation is actually a 1-bit boolean
      ast->ty.ty = AST_TYPE_INTEGER;
      ast->ty.integer.is_signed = 0;
      ast->ty.integer.width = 1;
      ast->ty = resolve_type(typecheck, &ast->ty);
      return &ast->ty;
    } break;

    case AST_EXPR_TYPE_BLOCK: {
      struct ast_ty *ty = typecheck_block(typecheck, &ast->block);
      ast->ty = resolve_type(typecheck, ty);
      return &ast->ty;
    } break;

    case AST_EXPR_TYPE_CALL: {
      struct scope_entry *entry =
          scope_lookup(typecheck->scope, ast->variable.ident.value.identv.ident, 1);
      if (!entry || !entry->fdecl) {
        fprintf(stderr, "%s not found or not a function\n", ast->variable.ident.value.identv.ident);
        ++typecheck->errors;
        return &typecheck->error_type;
      }

      if (!ast->call.args) {
        // no arguments passed
        if (entry->fdecl->num_params > 0) {
          fprintf(stderr, "function %s called with no arguments, expected %zu\n",
                  ast->variable.ident.value.identv.ident, entry->fdecl->num_params);
          ++typecheck->errors;
          return &typecheck->error_type;
          ;
        }
      } else if (entry->fdecl->num_params != ast->call.args->num_elements) {
        if ((entry->fdecl->flags & DECL_FLAG_VARARG) == 0 ||
            (ast->call.args->num_elements < entry->fdecl->num_params)) {
          fprintf(stderr, "function %s called with %zu arguments, expected %zu\n",
                  ast->variable.ident.value.identv.ident, ast->call.args->num_elements,
                  entry->fdecl->num_params);
          ++typecheck->errors;
          return &typecheck->error_type;
          ;
        }
      }

      ast->call.fdecl = entry->fdecl;

      struct ast_expr_list *args = ast->call.args;
      size_t i = 0;
      while (args) {
        struct ast_ty *arg_ty = typecheck_expr(typecheck, args->expr);
        if (!arg_ty) {
          return NULL;
        }

        // check named parameters, don't check varargs (no types to check)
        if (i < entry->fdecl->num_params) {
          maybe_implicitly_convert(arg_ty, &entry->fdecl->params[i]->ty);
          if (!same_type(arg_ty, &entry->fdecl->params[i]->ty)) {
            char tystr[256], expectedstr[256];
            type_name_into(arg_ty, tystr, 256);
            type_name_into(&entry->fdecl->params[i]->ty, expectedstr, 256);

            fprintf(stderr, "function %s argument %zu has type %s, expected %s\n",
                    ast->variable.ident.value.identv.ident, i + 1, tystr, expectedstr);
            ++typecheck->errors;
          }
        }

        args = args->next;
        ++i;
      }

      ast->ty = resolve_type(typecheck, &entry->fdecl->retty);
      return &ast->ty;
    } break;

    case AST_EXPR_TYPE_DEREF: {
      struct scope_entry *entry =
          scope_lookup(typecheck->scope, ast->deref.ident.value.identv.ident, 1);
      if (!entry || !entry->vdecl) {
        fprintf(stderr, "%s not found or not a variable\n", ast->deref.ident.value.identv.ident);
        ++typecheck->errors;
        return &typecheck->error_type;
      }

      if (entry->vdecl->ty.ty != AST_TYPE_FVEC && entry->vdecl->ty.ty != AST_TYPE_STRUCT) {
        char tystr[256];
        type_name_into(&entry->vdecl->ty, tystr, 256);

        fprintf(stderr, "deref %s has type %s, expected a vector or struct type\n",
                ast->variable.ident.value.identv.ident, tystr);
        ++typecheck->errors;
        return &typecheck->error_type;
      }

      size_t max_field = 0;

      if (entry->vdecl->ty.ty == AST_TYPE_FVEC) {
        int deref = deref_to_index(ast->deref.field.value.identv.ident);
        if (deref < 0) {
          fprintf(stderr, "fvec deref %s has unknown field %s\n",
                  ast->variable.ident.value.identv.ident, ast->deref.field.value.identv.ident);
          ++typecheck->errors;
          return &typecheck->error_type;
          ;
        }
        ast->deref.field_idx = (size_t)deref;
        max_field = entry->vdecl->ty.fvec.width;

        ast->ty.ty = AST_TYPE_FLOAT;
      } else if (entry->vdecl->ty.ty == AST_TYPE_STRUCT) {
        struct ast_struct_field *field = entry->vdecl->ty.structty.fields;
        size_t i = 0;
        while (field) {
          if (strcmp(field->name, ast->deref.field.value.identv.ident) == 0) {
            ast->deref.field_idx = i;
            break;
          }
          field = field->next;
          ++i;
        }

        if (!field) {
          fprintf(stderr, "struct deref %s references unknown field %s\n",
                  ast->variable.ident.value.identv.ident, ast->deref.field.value.identv.ident);
          ++typecheck->errors;
          return &typecheck->error_type;
          ;
        }

        ast->ty = *field->ty;
        max_field = entry->vdecl->ty.structty.num_fields;
      }

      // can't deref past the width of the vector
      if (ast->deref.field_idx >= max_field) {
        fprintf(stderr, "deref %s has field #%zd, exceeding field count of %zd\n",
                ast->variable.ident.value.identv.ident, ast->deref.field_idx, max_field);
        ++typecheck->errors;
        return &typecheck->error_type;
      }

      ast->ty = resolve_type(typecheck, &ast->ty);
      return &ast->ty;
    }; break;

    case AST_EXPR_TYPE_VOID:
      ast->ty = type_void();
      return &ast->ty;

    case AST_EXPR_TYPE_CAST: {
      ast->cast.ty = resolve_type(typecheck, &ast->cast.ty);

      struct ast_ty *expr_ty = typecheck_expr(typecheck, ast->cast.expr);
      if (!expr_ty) {
        return NULL;
      }

      if (!can_cast(&ast->cast.ty, expr_ty)) {
        char tystr[256], exprstr[256];
        type_name_into(&ast->cast.ty, tystr, 256);
        type_name_into(expr_ty, exprstr, 256);

        fprintf(stderr, "incompatible cast from %s to %s\n", exprstr, tystr);
        ++typecheck->errors;
        return &typecheck->error_type;
      }

      ast->ty = resolve_type(typecheck, &ast->cast.ty);
      return &ast->ty;
    } break;

    case AST_EXPR_TYPE_IF: {
      struct ast_ty *cond = typecheck_expr(typecheck, ast->if_expr.cond);
      if (!cond) {
        return NULL;
      }

      struct ast_ty *then_ty = typecheck_block(typecheck, &ast->if_expr.then_block);
      if (!then_ty) {
        return NULL;
      }

      if (ast->if_expr.has_else) {
        struct ast_ty *else_ty = typecheck_block(typecheck, &ast->if_expr.else_block);
        if (!else_ty) {
          return NULL;
        }

        if (!same_type(then_ty, else_ty)) {
          char thenstr[256], elsestr[256];
          type_name_into(then_ty, thenstr, 256);
          type_name_into(else_ty, elsestr, 256);

          fprintf(stderr, "if then block has type %s, else block has type %s\n", thenstr, elsestr);
          ++typecheck->errors;
          return &typecheck->error_type;
        }
      }

      if (then_ty->ty != AST_TYPE_VOID && !ast->if_expr.has_else) {
        fprintf(stderr, "an else block is required when if is used as an expression\n");
        ++typecheck->errors;
        return &typecheck->error_type;
      }

      ast->ty = resolve_type(typecheck, then_ty);
      return &ast->ty;
    } break;

    case AST_EXPR_TYPE_ASSIGN: {
      const char *ident = ast->assign.ident.value.identv.ident;
      struct scope_entry *entry = scope_lookup(typecheck->scope, ident, 1);
      if (!entry || !entry->vdecl) {
        fprintf(stderr, "%s not found or not a variable\n", ident);
        ++typecheck->errors;
        return &typecheck->error_type;
      }

      if (!(entry->vdecl->flags & DECL_FLAG_MUT)) {
        fprintf(stderr, "%s is not mutable\n", ident);
        ++typecheck->errors;
        return &typecheck->error_type;
      }

      struct ast_ty *expr_ty = typecheck_expr_with_tbds(typecheck, ast->assign.expr);
      if (!expr_ty) {
        return NULL;
      }

      if (type_is_tbd(&entry->vdecl->ty)) {
        // inferred type
        entry->vdecl->ty = *expr_ty;

        // remove constant flag if it was inferred
        entry->vdecl->ty.flags &= ~TYPE_FLAG_CONSTANT;
      }

      maybe_implicitly_convert(expr_ty, &entry->vdecl->ty);

      if (!same_type(&entry->vdecl->ty, expr_ty)) {
        char tystr[256], exprstr[256];
        type_name_into(&entry->vdecl->ty, tystr, 256);
        type_name_into(expr_ty, exprstr, 256);

        fprintf(stderr, "assignment to %s has type %s, expected %s\n", ident, exprstr, tystr);
        ++typecheck->errors;
        return &typecheck->error_type;
      }

      ast->ty = resolve_type(typecheck, expr_ty);
      return &ast->ty;
    } break;

    case AST_EXPR_TYPE_REF: {
      struct ast_expr *expr = ast->ref.expr;

      if (expr->type != AST_EXPR_TYPE_VARIABLE) {
        fprintf(stderr, "ref expression must resolve to an identifier\n");
        ++typecheck->errors;
        return &typecheck->error_type;
      }

      const char *ident = expr->variable.ident.value.identv.ident;

      struct scope_entry *entry = scope_lookup(typecheck->scope, ident, 1);
      if (!entry || !entry->vdecl) {
        fprintf(stderr, "%s not found or not a variable\n", ident);
        ++typecheck->errors;
        return &typecheck->error_type;
      }

      ast->ty = entry->vdecl->ty;
      ast->ty.flags |= TYPE_FLAG_PTR;
      ast->ref.expr->ty.flags |= TYPE_FLAG_PTR;
      ast->ty = resolve_type(typecheck, &ast->ty);
      return &ast->ty;
    } break;

    case AST_EXPR_TYPE_LOAD: {
      struct ast_expr *expr = ast->load.expr;

      struct ast_ty *expr_ty = typecheck_expr(typecheck, expr);
      if (!expr_ty) {
        return NULL;
      }

      if (!(expr_ty->flags & TYPE_FLAG_PTR)) {
        fprintf(stderr, "load expression must resolve to a pointer\n");
        ++typecheck->errors;
        return &typecheck->error_type;
      }

      ast->ty = *expr_ty;
      ast->ty.flags &= ~TYPE_FLAG_PTR;
      ast->ty = resolve_type(typecheck, &ast->ty);
      return &ast->ty;
    } break;

    case AST_EXPR_TYPE_UNARY: {
      struct ast_ty *expr_ty = typecheck_expr(typecheck, ast->unary.expr);
      if (!expr_ty) {
        return NULL;
      }

      switch (ast->unary.op) {
        case AST_UNARY_OP_NEG:
          if (expr_ty->ty != AST_TYPE_INTEGER && expr_ty->ty != AST_TYPE_FLOAT) {
            fprintf(stderr, "negation expression must resolve to an integer or float\n");
            ++typecheck->errors;
            return &typecheck->error_type;
            ;
          }

          ast->ty = resolve_type(typecheck, expr_ty);
          return &ast->ty;

        case AST_UNARY_OP_NOT:
          if (expr_ty->ty != AST_TYPE_INTEGER) {
            fprintf(stderr, "not expression must resolve to an integer\n");
            ++typecheck->errors;
            return &typecheck->error_type;
            ;
          }

          ast->ty = resolve_type(typecheck, expr_ty);
          return &ast->ty;

        case AST_UNARY_OP_COMP:
          if (expr_ty->ty != AST_TYPE_INTEGER) {
            fprintf(stderr, "complement expression must resolve to an integer\n");
            ++typecheck->errors;
            return &typecheck->error_type;
            ;
          }

          ast->ty = resolve_type(typecheck, expr_ty);
          return &ast->ty;

        default:
          fprintf(stderr, "unhandled unary op %d\n", ast->unary.op);
          ++typecheck->errors;
          return &typecheck->error_type;
          ;
      }
    } break;

    case AST_EXPR_TYPE_BOOLEAN: {
      struct ast_ty *lhs = typecheck_expr(typecheck, ast->boolean.lhs);
      struct ast_ty *rhs = typecheck_expr(typecheck, ast->boolean.rhs);

      if (!lhs || !rhs) {
        return NULL;
      }

      ast->ty.ty = AST_TYPE_INTEGER;
      ast->ty.integer.is_signed = 0;
      ast->ty.integer.width = 1;
      ast->ty = resolve_type(typecheck, &ast->ty);
      return &ast->ty;
    } break;

    case AST_EXPR_TYPE_MATCH: {
      struct ast_ty *expr_ty = typecheck_expr(typecheck, ast->match.expr);
      if (!expr_ty) {
        return NULL;
      }

      // first pass: check that all arms have the same pattern type, and check their expressions
      struct ast_expr_match_arm *arm = ast->match.arms;
      while (arm) {
        struct ast_ty *pattern_ty = typecheck_expr(typecheck, arm->pattern);
        if (!pattern_ty) {
          return NULL;
        }

        maybe_implicitly_convert(pattern_ty, expr_ty);

        if (!same_type(pattern_ty, expr_ty)) {
          char wantstr[256], gotstr[256];
          type_name_into(pattern_ty, wantstr, 256);
          type_name_into(expr_ty, gotstr, 256);

          typecheck_diag_expr(typecheck, ast,
                              "match pattern has incorrect type, wanted %s but got %s\n", wantstr,
                              gotstr);
          ++typecheck->errors;
          return &typecheck->error_type;
          ;
        }

        struct scope_entry *inner_var = NULL;

        if (arm->pattern->type == AST_EXPR_TYPE_PATTERN_MATCH &&
            arm->pattern->pattern_match.inner_vdecl) {
          typecheck->scope = enter_scope(typecheck->scope);

          struct scope_entry *entry = calloc(1, sizeof(struct scope_entry));
          entry->vdecl = arm->pattern->pattern_match.inner_vdecl;
          scope_insert(typecheck->scope,
                       arm->pattern->pattern_match.inner_vdecl->ident.value.identv.ident, entry);

          inner_var = entry;
        }

        struct ast_ty *arm_ty = typecheck_expr(typecheck, arm->expr);

        if (inner_var) {
          typecheck->scope = exit_scope(typecheck->scope);
        }

        if (!arm_ty) {
          return NULL;
        }

        arm = arm->next;
      }

      if (!ast->match.otherwise) {
        typecheck_diag_expr(typecheck, ast, "match expression has no otherwise arm\n");
        ++typecheck->errors;
        return &typecheck->error_type;
      }

      struct ast_ty *otherwise_ty = typecheck_expr(typecheck, ast->match.otherwise->expr);
      if (!otherwise_ty) {
        return NULL;
      }

      struct ast_ty *largest_ty = otherwise_ty;

      // second pass: check that all arms have the same type
      arm = ast->match.arms;
      while (arm) {
        struct ast_expr_match_arm *next = arm->next ? arm->next : ast->match.otherwise;
        if (next) {
          if (!maybe_implicitly_convert(&arm->expr->ty, &next->expr->ty)) {
            maybe_implicitly_convert(&next->expr->ty, &arm->expr->ty);
          }

          if (!same_type(&arm->expr->ty, &next->expr->ty)) {
            char armstr[256], nextstr[256];
            type_name_into(&arm->expr->ty, armstr, 256);
            type_name_into(&next->expr->ty, nextstr, 256);

            typecheck_diag_expr(typecheck, ast,
                                "match arm has type %s, next arm has mismatched type %s\n", armstr,
                                nextstr);
            ++typecheck->errors;
            return &typecheck->error_type;
            ;
          }

          if (wider_type(&arm->expr->ty, largest_ty)) {
            largest_ty = &arm->expr->ty;
          }
        }

        arm = arm->next;
      }

      ast->ty = resolve_type(typecheck, largest_ty);
      return &ast->ty;
    } break;

    case AST_EXPR_TYPE_NIL:
      ast->ty.ty = AST_TYPE_NIL;
      return &ast->ty;

    case AST_EXPR_TYPE_ENUM_INIT: {
      struct alias_entry *entry =
          kv_lookup(typecheck->aliases, ast->enum_init.enum_ty_name.value.identv.ident);
      if (!entry) {
        typecheck_diag_expr(typecheck, ast, "enum type %s not found\n",
                            ast->enum_init.enum_ty_name.value.identv.ident);
        return &typecheck->error_type;
      }

      if (entry->ty.ty != AST_TYPE_ENUM) {
        typecheck_diag_expr(typecheck, ast, "type %s is not an enum\n",
                            ast->enum_init.enum_ty_name.value.identv.ident);
        return &typecheck->error_type;
      }

      struct ast_enum_field *field = entry->ty.enumty.fields;
      while (field) {
        if (!strcmp(field->name, ast->enum_init.enum_val_name.value.identv.ident)) {
          break;
        }
        field = field->next;
      }

      if (!field) {
        typecheck_diag_expr(typecheck, ast, "enum field %s not found in enum %s\n",
                            ast->enum_init.enum_val_name.value.identv.ident,
                            ast->enum_init.enum_ty_name.value.identv.ident);
        return &typecheck->error_type;
      }

      if (ast->enum_init.inner) {
        if (!field->has_inner) {
          typecheck_diag_expr(typecheck, ast, "enum field %s does not have an inner\n",
                              field->name);
          return &typecheck->error_type;
        }

        // includes an inner, ensure it matches the enum field's type
        struct ast_ty *inner_ty = typecheck_expr(typecheck, ast->enum_init.inner);
        if (!inner_ty) {
          return NULL;
        }

        maybe_implicitly_convert(inner_ty, &field->inner);

        if (!same_type(inner_ty, &field->inner)) {
          char innerstr[256], fieldstr[256];
          type_name_into(inner_ty, innerstr, 256);
          type_name_into(&field->inner, fieldstr, 256);

          typecheck_diag_expr(typecheck, ast,
                              "enum field %s wraps type %s, but was given type %s instead\n",
                              field->name, fieldstr, innerstr);
          return &typecheck->error_type;
        }

        ast->enum_init.field_ty = resolve_type(typecheck, &field->inner);
      } else {
        // default to integer if no inner is provided
        ast->enum_init.field_ty.ty = AST_TYPE_INTEGER;
        ast->enum_init.field_ty.integer.is_signed = 1;
        ast->enum_init.field_ty.integer.width = 32;
      }

      ast->ty = resolve_type(typecheck, &entry->ty);
      return &ast->ty;
    } break;

    case AST_EXPR_TYPE_PATTERN_MATCH: {
      struct alias_entry *entry =
          kv_lookup(typecheck->aliases, ast->enum_init.enum_ty_name.value.identv.ident);
      if (!entry) {
        typecheck_diag_expr(typecheck, ast, "enum type %s not found\n",
                            ast->enum_init.enum_ty_name.value.identv.ident);
        return &typecheck->error_type;
      }

      if (entry->ty.ty != AST_TYPE_ENUM) {
        typecheck_diag_expr(typecheck, ast, "type %s is not an enum\n",
                            ast->enum_init.enum_ty_name.value.identv.ident);
        return &typecheck->error_type;
      }

      struct ast_enum_field *field = entry->ty.enumty.fields;
      while (field) {
        if (!strcmp(field->name, ast->enum_init.enum_val_name.value.identv.ident)) {
          break;
        }
        field = field->next;
      }

      if (!field) {
        typecheck_diag_expr(typecheck, ast, "enum field %s not found in enum %s\n",
                            ast->enum_init.enum_val_name.value.identv.ident,
                            ast->enum_init.enum_ty_name.value.identv.ident);
        return &typecheck->error_type;
      }

      if (ast->pattern_match.inner_vdecl) {
        ast->pattern_match.inner_vdecl->ty = resolve_type(typecheck, &field->inner);
      }

      // no need to check inner, it'll become the type of the pattern match in the handler for the
      // match expression
      ast->ty = resolve_type(typecheck, &entry->ty);
      return &ast->ty;
    } break;

    default:
      typecheck_diag_expr(typecheck, ast, "typecheck: unhandled expression type %d\n", ast->type);
  }

  // all expressions must resolve to a type
  return &typecheck->void_type;
}

static int binary_mismatch_ok(int op, struct ast_ty *lhs, struct ast_ty *rhs) {
  // float/fvec can mix but only for certain operations
  // e.g. scale, division
  if ((lhs->ty == AST_TYPE_FVEC && rhs->ty == AST_TYPE_FLOAT) ||
      (lhs->ty == AST_TYPE_FLOAT && rhs->ty == AST_TYPE_FVEC)) {
    return op == AST_BINARY_OP_MUL || op == AST_BINARY_OP_DIV || op == AST_BINARY_OP_MOD;
  }

  return 0;
}

static struct ast_ty resolve_type(struct typecheck *typecheck, struct ast_ty *ty) {
  if (ty->ty != AST_TYPE_CUSTOM) {
    return copy_type(ty);
  }

  struct alias_entry *entry = kv_lookup(typecheck->aliases, ty->name);
  if (!entry) {
    return type_error();
  }

  // copy flags from original type (e.g. ptr); don't mutate original type
  struct ast_ty resolved_type = copy_type(&entry->ty);
  resolved_type.flags |= ty->flags;
  resolved_type.flags |= TYPE_FLAG_INDIRECT;
  return resolved_type;
}

static int deref_to_index(const char *deref) {
  if (isdigit(*deref)) {
    // numeric deref
    // TODO: check that endptr is the end of deref; fully consume the string
    return (int)strtol(deref, NULL, 10);
  }

  if (deref[1] == 0) {
    // single character deref
    switch (deref[0]) {
      // XYZW
      case 'x':
      case 'y':
      case 'z':
        return deref[0] - 'x';
      case 'w':
        return 3;

      // RGBA
      case 'r':
        return 0;
      case 'g':
        return 1;
      case 'b':
        return 2;
      case 'a':
        return 3;
    }
  }

  return -1;
}

int maybe_implicitly_convert(struct ast_ty *from, struct ast_ty *to) {
  if (type_is_tbd(to)) {
    *to = *from;
    return 1;
  }

  if (!compatible_types(from, to)) {
    // no-op
    return 0;
  }

  if (from->ty == AST_TYPE_INTEGER && to->ty == AST_TYPE_INTEGER) {
    if (from->integer.width == to->integer.width) {
      return 0;
    }

    if (from->flags & TYPE_FLAG_CONSTANT && to->flags & TYPE_FLAG_CONSTANT) {
      // swap from/to so the result is the highest width
      if (from->integer.width > to->integer.width) {
        to->integer.width = from->integer.width;
      } else {
        from->integer.width = to->integer.width;
      }

      return from->integer.width != to->integer.width;
    }

    // don't propagate constant type in the wrong direction
    if (to->flags & TYPE_FLAG_CONSTANT) {
      return 0;
    }

    // convert the source width to the destinaiton width
    from->integer.width = to->integer.width;
    return 1;
  }

  return 0;
}
