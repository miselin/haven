#include "typecheck.h"

#include <ctype.h>
#include <malloc.h>
#include <stdarg.h>
#include <stdlib.h>
#include <string.h>

#include "ast.h"
#include "compiler.h"
#include "kv.h"
#include "scope.h"
#include "tokens.h"
#include "types.h"
#include "utility.h"

struct scope_entry {
  struct ast_vdecl *vdecl;
  struct ast_fdecl *fdecl;
};

struct alias_entry {
  struct ast_ty ty;
};

struct typecheck {
  struct ast_program *ast;

  struct scope *scope;

  int errors;

  struct kv *aliases;

  struct ast_ty void_type;
  struct ast_ty error_type;
  struct ast_ty tbd_type;

  struct compiler *compiler;
};

int typecheck_verify_ast(struct ast_program *ast);
int typecheck_implicit_ast(struct ast_program *ast);

static void typecheck_ast(struct typecheck *typecheck, struct ast_program *ast);
static void typecheck_toplevel(struct typecheck *typecheck, struct ast_toplevel *ast);
static struct ast_ty *typecheck_block(struct typecheck *typecheck, struct ast_block *ast);
static struct ast_ty *typecheck_stmt(struct typecheck *typecheck, struct ast_stmt *ast);
static struct ast_ty *typecheck_expr(struct typecheck *typecheck, struct ast_expr *ast)
    __attribute__((warn_unused_result));
// Allow TBD types to be generated by the expression
static struct ast_ty *typecheck_expr_with_tbds(struct typecheck *typecheck, struct ast_expr *ast);
static struct ast_ty *typecheck_expr_inner(struct typecheck *typecheck, struct ast_expr *ast);

static struct ast_ty *typecheck_pattern_match(struct typecheck *typecheck, struct ast_expr *ast,
                                              struct ast_expr_pattern_match *pattern,
                                              struct ast_ty *match_ty);

static struct ast_ty resolve_type(struct typecheck *typecheck, struct ast_ty *ty);

static void typecheck_struct_decl(struct typecheck *typecheck, struct ast_ty *decl);
static void typecheck_enum_decl(struct typecheck *typecheck, struct ast_ty *decl);

static int binary_mismatch_ok(int op, struct ast_ty *lhs, struct ast_ty *rhs);
static int check_matrix_binary_op(int op, struct ast_ty *lhs, struct ast_ty *rhs);

static int deref_to_index(const char *deref);

// If allowed, makes from and to the same type using implicit conversion rules
// Does nothing if implicit conversion is disallowed or irrelevant.
int maybe_implicitly_convert(struct ast_ty *from, struct ast_ty *to);

static void resolve_template_type(struct typecheck *typecheck, struct ast_template_ty *templates,
                                  struct ast_ty *ty);

__attribute__((format(printf, 3, 4))) static void typecheck_diag_expr(struct typecheck *typecheck,
                                                                      struct ast_expr *expr,
                                                                      const char *msg, ...) {
  char msgbuf[1024];

  va_list args;
  va_start(args, msg);
  vsprintf(msgbuf, msg, args);
  va_end(args);

  compiler_diag(typecheck->compiler, DiagError, "%s:%zu:%zu: %s", expr->loc.file, expr->loc.line,
                expr->loc.column, msgbuf);

  ++typecheck->errors;
}

struct typecheck *new_typecheck(struct ast_program *ast, struct compiler *compiler) {
  struct typecheck *result = calloc(1, sizeof(struct typecheck));
  result->ast = ast;
  result->scope = enter_scope(NULL);
  result->aliases = new_kv();
  result->error_type = type_error();
  result->void_type = type_void();
  result->tbd_type = type_tbd();
  result->compiler = compiler;
  return result;
}

int typecheck_run(struct typecheck *typecheck) {
  typecheck_ast(typecheck, typecheck->ast);
  if (typecheck->errors) {
    return typecheck->errors;
  }
  int rc = 0;
  while (1) {
    rc = typecheck_implicit_ast(typecheck->ast);
    if (rc < 0) {
      return 1;
    }

    if (rc == 0) {
      break;
    }
  }
  if (typecheck_verify_ast(typecheck->ast) < 0) {
    return 1;
  }
  return 0;
}

void destroy_typecheck(struct typecheck *typecheck) {
  exit_scope(typecheck->scope);
  void *iter = kv_iter(typecheck->aliases);
  while (!kv_end(iter)) {
    struct alias_entry *entry = kv_next(&iter);
    free(entry);
  }
  destroy_kv(typecheck->aliases);
  free(typecheck);
}

static void typecheck_ast(struct typecheck *typecheck, struct ast_program *ast) {
  struct ast_toplevel *decl = ast->decls;
  while (decl) {
    typecheck_toplevel(typecheck, decl);
    decl = decl->next;
  }
}

static void typecheck_toplevel(struct typecheck *typecheck, struct ast_toplevel *ast) {
  if (ast->type == AST_DECL_TYPE_FDECL) {
    struct ast_ty resolved = resolve_type(typecheck, &ast->fdecl.retty);
    free_ty(&ast->fdecl.retty, 0);
    ast->fdecl.retty = resolved;
    if (type_is_error(&ast->fdecl.retty) || type_is_tbd(&ast->fdecl.retty)) {
      fprintf(stderr, "function %s has unresolved return type\n",
              ast->fdecl.ident.value.identv.ident);
      ++typecheck->errors;
      return;
    }

    // specialize the return type if it's a template
    if (ast->fdecl.retty.ty == AST_TYPE_ENUM && ast->fdecl.retty.enumty.templates) {
      // create a specialized type and use it here
      struct ast_ty new_type;
      memset(&new_type, 0, sizeof(struct ast_ty));
      new_type.ty = AST_TYPE_ENUM;
      char new_name[1024];
      if (snprintf(new_name, 1024, "%s_spec_%s", ast->fdecl.ident.value.identv.ident,
                   ast->fdecl.retty.name) > 256) {
        fprintf(stderr, "enum specialization name too long\n");
        ++typecheck->errors;
        return;
      }
      strcpy(new_type.name, new_name);

      new_type.enumty.fields = ast->fdecl.retty.enumty.fields;
      new_type.enumty.no_wrapped_fields = ast->fdecl.retty.enumty.no_wrapped_fields;
      new_type.enumty.num_fields = ast->fdecl.retty.enumty.num_fields;
      new_type.enumty.templates = ast->fdecl.retty.enumty.templates;

      new_type.specialization_of = strdup(ast->fdecl.retty.name);

      /*
          new_type.enumty.fields = ast->fdecl.retty.template.outer->enumty.fields;
          new_type.enumty.no_wrapped_fields =
         ast->fdecl.retty.template.outer->enumty.no_wrapped_fields; new_type.enumty.num_fields =
         ast->fdecl.retty.template.outer->enumty.num_fields;
          */
      ast->fdecl.retty = new_type;
    }

    struct scope_entry *existing =
        scope_lookup(typecheck->scope, ast->fdecl.ident.value.identv.ident, 1);

    struct scope_entry *entry = calloc(1, sizeof(struct scope_entry));
    entry->fdecl = &ast->fdecl;

    scope_insert(typecheck->scope, ast->fdecl.ident.value.identv.ident, entry);

    if (existing && entry->fdecl->flags != existing->fdecl->flags) {
      fprintf(stderr, "function %s redeclared with different flags\n",
              ast->fdecl.ident.value.identv.ident);
      ++typecheck->errors;
    }

    if (existing && !same_type(&entry->fdecl->retty, &existing->fdecl->retty)) {
      char tystr[256], existingstr[256];
      type_name_into(&entry->fdecl->retty, tystr, 256);
      type_name_into(&existing->fdecl->retty, existingstr, 256);

      fprintf(stderr, "function %s redeclared with different return type %s, expected %s\n",
              ast->fdecl.ident.value.identv.ident, tystr, existingstr);
      ++typecheck->errors;
    }

    if (existing && entry->fdecl->num_params != existing->fdecl->num_params) {
      fprintf(stderr,
              "function %s redeclared with different number of parameters %zu, expected %zu\n",
              ast->fdecl.ident.value.identv.ident, entry->fdecl->num_params,
              existing->fdecl->num_params);
      ++typecheck->errors;
    }

    for (size_t i = 0; i < entry->fdecl->num_params; ++i) {
      struct ast_ty old_ty = entry->fdecl->params[i]->ty;
      entry->fdecl->params[i]->ty = resolve_type(typecheck, &entry->fdecl->params[i]->ty);
      free_ty(&old_ty, 0);

      if (existing && !same_type(&entry->fdecl->params[i]->ty, &existing->fdecl->params[i]->ty)) {
        char tystr[256], existingstr[256];
        type_name_into(&entry->fdecl->params[i]->ty, tystr, 256);
        type_name_into(&existing->fdecl->params[i]->ty, existingstr, 256);

        fprintf(stderr, "function %s parameter %zu has type %s, expected %s\n",
                ast->fdecl.ident.value.identv.ident, i, tystr, existingstr);
        ++typecheck->errors;
      }
    }

    // done with the old entry, new definition is compatible
    if (existing) {
      free(existing);
    }

    if (ast->fdecl.body) {
      typecheck->scope = enter_scope(typecheck->scope);

      // declare the parameters in the function scope
      for (size_t i = 0; i < ast->fdecl.num_params; i++) {
        struct scope_entry *param_entry = calloc(1, sizeof(struct scope_entry));
        param_entry->vdecl = ast->fdecl.params[i];
        scope_insert(typecheck->scope, ast->fdecl.params[i]->ident.value.identv.ident, param_entry);
      }

      struct ast_ty *result = typecheck_block(typecheck, ast->fdecl.body);

      typecheck->scope = exit_scope(typecheck->scope);

      if (!result) {
        return;
      }

      maybe_implicitly_convert(result, &ast->fdecl.retty);

      if (!same_type(result, &ast->fdecl.retty)) {
        char resultstr[256], tystr[256];
        type_name_into(result, resultstr, 256);
        type_name_into(&ast->fdecl.retty, tystr, 256);

        fprintf(stderr, "function %s returns %s, expected %s\n",
                ast->fdecl.ident.value.identv.ident, resultstr, tystr);
        ++typecheck->errors;
        return;
      }
    }
  } else if (ast->type == AST_DECL_TYPE_VDECL) {
    struct ast_ty new_type = resolve_type(typecheck, &ast->vdecl.ty);
    if (type_is_error(&new_type) || type_is_tbd(&new_type)) {
      fprintf(stderr, "variable %s has unresolved type\n", ast->vdecl.ident.value.identv.ident);
      ++typecheck->errors;
      return;
    }

    // resolve creates a copy, clean up old type
    free_ty(&ast->vdecl.ty, 0);
    ast->vdecl.ty = new_type;

    if (ast->vdecl.init_expr) {
      struct scope_entry *existing =
          scope_lookup(typecheck->scope, ast->vdecl.ident.value.identv.ident, 0);
      if (existing) {
        fprintf(stderr, "typecheck: multiple definitions of variable %s\n",
                ast->vdecl.ident.value.identv.ident);
        ++typecheck->errors;
        return;
      }

      struct scope_entry *entry = calloc(1, sizeof(struct scope_entry));
      entry->vdecl = &ast->vdecl;

      // insert before checking the initializer to allow recursive references
      scope_insert(typecheck->scope, ast->vdecl.ident.value.identv.ident, entry);

      struct ast_ty *result = typecheck_expr(typecheck, ast->vdecl.init_expr);
      if (!result) {
        return;
      }

      maybe_implicitly_convert(result, &ast->vdecl.ty);

      if (!same_type(result, &ast->vdecl.ty)) {
        char resultstr[256], tystr[256];
        type_name_into(result, resultstr, 256);
        type_name_into(&ast->vdecl.ty, tystr, 256);

        typecheck_diag_expr(typecheck, ast->vdecl.init_expr,
                            "variable %s initializer has type %s, expected %s\n",
                            ast->vdecl.ident.value.identv.ident, resultstr, tystr);
        ++typecheck->errors;
        return;
      }
    }
  } else if (ast->type == AST_DECL_TYPE_TYDECL) {
    struct alias_entry *entry = calloc(1, sizeof(struct alias_entry));
    entry->ty = ast->tydecl.ty;
    kv_insert(typecheck->aliases, ast->tydecl.ident.value.identv.ident, entry);

    if (ast->tydecl.ty.ty == AST_TYPE_STRUCT) {
      typecheck_struct_decl(typecheck, &ast->tydecl.ty);
    } else if (ast->tydecl.ty.ty == AST_TYPE_ENUM) {
      typecheck_enum_decl(typecheck, &ast->tydecl.ty);
    } else if (ast->tydecl.ty.ty == AST_TYPE_ARRAY) {
      struct ast_ty resolved = resolve_type(typecheck, ast->tydecl.ty.array.element_ty);
      free_ty(ast->tydecl.ty.array.element_ty, 0);
      *ast->tydecl.ty.array.element_ty = resolved;
    } else if (ast->tydecl.ty.ty == AST_TYPE_FUNCTION) {
      struct ast_ty resolved = resolve_type(typecheck, ast->tydecl.ty.function.retty);
      free_ty(ast->tydecl.ty.function.retty, 0);
      *ast->tydecl.ty.function.retty = resolved;

      for (size_t i = 0; i < ast->tydecl.ty.function.num_args; i++) {
        struct ast_ty arg_resolved = resolve_type(typecheck, ast->tydecl.ty.function.args[i]);
        free_ty(ast->tydecl.ty.function.args[i], 0);
        *ast->tydecl.ty.function.args[i] = arg_resolved;
      }
    } else {
      struct ast_ty resolved = resolve_type(typecheck, &ast->tydecl.ty);
      free_ty(&ast->tydecl.ty, 0);
      ast->tydecl.ty = resolved;
    }

    entry->ty = ast->tydecl.ty;
  }
}

static void typecheck_struct_decl(struct typecheck *typecheck, struct ast_ty *decl) {
  // TODO: causes infinite recursive loop on recursive struct definitions

  struct ast_struct_field *field = decl->structty.fields;
  while (field) {
    // TODO: check for recursive definition, ensure it's a pointer if so, or it's not representable
    struct ast_ty resolved = resolve_type(typecheck, field->ty);
    free_ty(field->ty, 0);
    *field->ty = resolved;
    field = field->next;
  }
}

static void typecheck_enum_decl(struct typecheck *typecheck, struct ast_ty *decl) {
  struct ast_enum_field *field = decl->enumty.fields;
  while (field) {
    if (field->has_inner) {
      resolve_template_type(typecheck, decl->enumty.templates, &field->inner);
      struct ast_ty resolved = resolve_type(typecheck, &field->inner);
      free_ty(&field->inner, 0);
      field->inner = resolved;
    }
    field = field->next;
  }
}

static struct ast_ty *typecheck_block(struct typecheck *typecheck, struct ast_block *ast) {
  typecheck->scope = enter_scope(typecheck->scope);

  struct ast_stmt *stmt = ast->stmt;
  struct ast_ty *last_ty = NULL;

  while (stmt) {
    struct ast_ty *ty = typecheck_stmt(typecheck, stmt);
    if (!ty) {
      return NULL;
    }

    last_ty = ty;
    stmt = stmt->next;
  }

  if (!last_ty) {
    last_ty = &typecheck->void_type;
  }

  typecheck->scope = exit_scope(typecheck->scope);

  ast->ty = resolve_type(typecheck, last_ty);
  return &ast->ty;
}

static struct ast_ty *typecheck_stmt(struct typecheck *typecheck, struct ast_stmt *ast) {
  switch (ast->type) {
    case AST_STMT_TYPE_EXPR:
      return typecheck_expr(typecheck, ast->expr);

    case AST_STMT_TYPE_LET: {
      struct scope_entry *entry = calloc(1, sizeof(struct scope_entry));
      entry->vdecl = &ast->let;

      // if a type was actually specified we need to resolve it
      if (!type_is_tbd(&ast->let.ty)) {
        struct ast_ty resolved = resolve_type(typecheck, &ast->let.ty);
        free_ty(&ast->let.ty, 0);
        ast->let.ty = resolved;
      }

      // insert before checking the initializer to allow recursive references
      scope_insert(typecheck->scope, ast->let.ident.value.identv.ident, entry);

      struct ast_ty *init_ty = typecheck_expr(typecheck, ast->let.init_expr);
      if (!init_ty) {
        return NULL;
      }

      if (type_is_tbd(&ast->let.ty)) {
        // inferred type
        ast->let.ty = copy_type(init_ty);
        ast->let.ty.flags &= ~TYPE_FLAG_CONSTANT;  // no longer a constant
      }

      maybe_implicitly_convert(init_ty, &ast->let.ty);

      if (!same_type(&ast->let.ty, init_ty)) {
        char tystr[256], initstr[256];
        type_name_into(&ast->let.ty, tystr, 256);
        type_name_into(init_ty, initstr, 256);

        typecheck_diag_expr(typecheck, ast->let.init_expr,
                            "let %s initializer has type %s, expected %s\n",
                            ast->let.ident.value.identv.ident, initstr, tystr);
        ++typecheck->errors;
      }

      // fully resolve the let type now that the initializer is known
      struct ast_ty resolved = resolve_type(typecheck, &ast->let.ty);
      free_ty(&ast->let.ty, 0);
      ast->let.ty = resolved;
    } break;

    case AST_STMT_TYPE_ITER: {
      struct ast_ty *start = typecheck_expr(typecheck, ast->iter.range.start);
      struct ast_ty *end = typecheck_expr(typecheck, ast->iter.range.end);
      struct ast_ty *step, step_ty;
      if (ast->iter.range.step) {
        step = typecheck_expr(typecheck, ast->iter.range.step);
      } else {
        step_ty.ty = AST_TYPE_INTEGER;
        step_ty.integer.is_signed = 1;
        step_ty.integer.width = 32;
        step = &step_ty;
      }

      if (!same_type(start, end)) {
        char startstr[256], endstr[256];
        type_name_into(start, startstr, 256);
        type_name_into(end, endstr, 256);

        fprintf(stderr, "iter range start has type %s, end has type %s\n", startstr, endstr);
        ++typecheck->errors;
      }

      if (ast->iter.range.step && !same_type(start, step)) {
        char startstr[256], stepstr[256];
        type_name_into(start, startstr, 256);
        type_name_into(step, stepstr, 256);

        fprintf(stderr, "iter range start has type %s, step has type %s\n", startstr, stepstr);
        ++typecheck->errors;
      }

      struct ast_vdecl *index = calloc(1, sizeof(struct ast_vdecl));

      struct scope_entry *entry = calloc(1, sizeof(struct scope_entry));
      entry->vdecl = index;
      entry->vdecl->ident = ast->iter.index.ident;
      entry->vdecl->ty = *start;
      ast->iter.index_vdecl = entry->vdecl;

      // new scope for the loop variable
      typecheck->scope = enter_scope(typecheck->scope);

      // insert before checking the initializer to allow recursive references
      scope_insert(typecheck->scope, ast->iter.index.ident.value.identv.ident, entry);

      typecheck_block(typecheck, &ast->iter.block);

      typecheck->scope = exit_scope(typecheck->scope);
    } break;

    case AST_STMT_TYPE_STORE: {
      struct ast_ty *lhs = typecheck_expr(typecheck, ast->store.lhs);
      struct ast_ty *rhs = typecheck_expr(typecheck, ast->store.rhs);

      if (!lhs || !rhs) {
        return NULL;
      }

      if (lhs->ty != AST_TYPE_POINTER) {
        fprintf(stderr, "store lhs is not a pointer\n");
        ++typecheck->errors;
      }

      struct ast_ty *pointee = ptr_pointee_type(lhs);

      if (!same_type(pointee, rhs)) {
        char lhsstr[256], rhsstr[256];
        type_name_into(pointee, lhsstr, 256);
        type_name_into(rhs, rhsstr, 256);

        fprintf(stderr, "store lhs has type %s, rhs has type %s\n", lhsstr, rhsstr);
        ++typecheck->errors;
      }

    } break;

    case AST_STMT_TYPE_RETURN: {
      // TODO: make sure this expr type matches the function's return type
      return typecheck_expr(typecheck, ast->expr);
    } break;

    case AST_STMT_TYPE_DEFER: {
      if (!typecheck_expr(typecheck, ast->expr)) {
        return NULL;
      }
      // expression type is irrelevant; defer is a void statement
    } break;

    case AST_STMT_TYPE_WHILE: {
      struct ast_ty *cond = typecheck_expr(typecheck, ast->while_stmt.cond);
      if (!cond) {
        return NULL;
      }

      // TODO: needs to be an integer condition

      typecheck_block(typecheck, &ast->while_stmt.block);
    } break;

    case AST_STMT_TYPE_BREAK:
    case AST_STMT_TYPE_CONTINUE:
      // no types to check
      break;

    default:
      typecheck_diag_expr(typecheck, NULL, "typecheck: unhandled statement type %d\n", ast->type);
  }

  // statements that aren't expressions do not have types (their expressions do)
  return &typecheck->void_type;
}

static struct ast_ty *typecheck_expr(struct typecheck *typecheck, struct ast_expr *ast) {
  struct ast_ty *ty = typecheck_expr_with_tbds(typecheck, ast);
  if (!ty) {
    return ty;
  }

  if (type_is_tbd(ty)) {
    typecheck_diag_expr(typecheck, ast,
                        "type is not yet resolved, but this context requires a resolved type\n");
    return NULL;
  }

  return ty;
}

static struct ast_ty *typecheck_expr_with_tbds(struct typecheck *typecheck, struct ast_expr *ast) {
  struct ast_ty *ty = typecheck_expr_inner(typecheck, ast);
  if (!ty) {
    return ty;
  }

  if (type_is_error(ty)) {
    typecheck_diag_expr(typecheck, ast, "type failed to resolve\n");
    return NULL;
  }

  return ty;
}

static struct ast_ty *typecheck_expr_inner(struct typecheck *typecheck, struct ast_expr *ast) {
  switch (ast->type) {
    case AST_EXPR_TYPE_CONSTANT: {
      struct ast_ty new_ty = resolve_type(typecheck, &ast->ty);
      free_ty(&ast->ty, 0);
      ast->ty = new_ty;

      switch (ast->ty.ty) {
        case AST_TYPE_FVEC:
        case AST_TYPE_ARRAY:
        case AST_TYPE_MATRIX: {
          struct ast_expr_list *node = ast->list;
          while (node) {
            struct ast_ty *ty = typecheck_expr(typecheck, node->expr);
            if (!ty) {
              return NULL;
            }

            if (ast->ty.ty == AST_TYPE_ARRAY) {
              if (ast->ty.array.element_ty->ty == AST_TYPE_MATRIX) {
                // swap to matrix type after checking the inners are actually fvecs
                if (ty->ty != AST_TYPE_FVEC) {
                  typecheck_diag_expr(typecheck, node->expr,
                                      "matrix initializer has non-fvec type\n");
                  return NULL;
                }
              }

              maybe_implicitly_convert(ty, ast->ty.array.element_ty);
            }

            node = node->next;
          }

          // convert from array to full matrix type
          if (ast->ty.ty == AST_TYPE_ARRAY) {
            if (ast->ty.array.element_ty->ty == AST_TYPE_MATRIX) {
              size_t correct_cols = ast->ty.array.element_ty->matrix.cols;
              size_t correct_rows = ast->ty.array.element_ty->matrix.rows;

              size_t rows = ast->ty.array.width;
              free_ty(ast->ty.array.element_ty, 1);

              ast->ty.ty = AST_TYPE_MATRIX;
              ast->ty.matrix.cols = ast->list->num_elements;
              ast->ty.matrix.rows = rows;

              if (ast->list->num_elements != correct_cols) {
                typecheck_diag_expr(typecheck, ast,
                                    "matrix initializer has %zu columns, expected %zu\n",
                                    ast->list->num_elements, correct_cols);
                return NULL;
              }
              if (rows != correct_rows) {
                typecheck_diag_expr(typecheck, ast,
                                    "matrix initializer has %zu rows, expected %zu\n",
                                    ast->list->num_elements, correct_rows);
                return NULL;
              }
            }
          }
        } break;
        default:
          break;
      }
      return &ast->ty;
    } break;

    case AST_EXPR_TYPE_STRUCT_INIT: {
      struct ast_ty resolved = resolve_type(typecheck, ast->ty.array.element_ty);

      // TODO: check each field initializer against the struct type
      struct ast_struct_field *field = resolved.structty.fields;
      struct ast_expr_list *node = ast->list;
      while (node) {
        struct ast_ty *expr_ty = typecheck_expr(typecheck, node->expr);
        if (!expr_ty) {
          return NULL;
        }

        if (type_is_nil(expr_ty)) {
          // swap expr type for the real underlying type for checking + codegen
          // the expr is a nil expression, so this is safe to do.
          *expr_ty = *field->ty;
        }

        // TODO: fuzzer found field to be null here, the AST doesn't make sense to cause that
        // either way though, we should check that both node & field are non-null
        if (!field) {
          fprintf(stderr, "struct initializer has more fields than the struct type\n");
          ++typecheck->errors;
          break;
        }

        if (!field->ty) {
          fprintf(stderr, "struct initializer field %s inexplicably has no type\n", field->name);
          ++typecheck->errors;
        }

        maybe_implicitly_convert(expr_ty, field->ty);

        if (!same_type(expr_ty, field->ty)) {
          char exprty[256];
          char fieldty[256];
          type_name_into(expr_ty, exprty, 256);
          type_name_into(field->ty, fieldty, 256);

          fprintf(stderr, "struct initializer field %s has type %s, expected %s\n", field->name,
                  exprty, fieldty);
          ++typecheck->errors;
        }

        node = node->next;
        field = field->next;
      }

      // original got copied when we resolved
      *ast->ty.array.element_ty = resolved;
      return ast->ty.array.element_ty;
    } break;

    case AST_EXPR_TYPE_UNION_INIT: {
      // unions are a simplified variant of structs - they initialize one field, and that's it
      struct ast_ty union_ty = resolve_type(typecheck, &ast->union_init.ty);
      free_ty(&ast->union_init.ty, 0);
      ast->union_init.ty = union_ty;

      if (type_is_error(&union_ty)) {
        typecheck_diag_expr(typecheck, ast, "union type could not be resolved\n");
        return &typecheck->error_type;
      }

      // find the field
      struct ast_struct_field *field = union_ty.structty.fields;
      while (field) {
        if (strcmp(field->name, ast->union_init.field.value.identv.ident) == 0) {
          break;
        }
        field = field->next;
      }

      if (!field) {
        typecheck_diag_expr(typecheck, ast, "union field %s not found\n",
                            ast->union_init.field.value.identv.ident);
        return &typecheck->error_type;
      }

      struct ast_ty *expr_ty = typecheck_expr(typecheck, ast->union_init.inner);
      if (!expr_ty) {
        return NULL;
      }

      maybe_implicitly_convert(expr_ty, field->ty);

      if (!same_type(expr_ty, field->ty)) {
        char exprty[256];
        char fieldty[256];
        type_name_into(expr_ty, exprty, 256);
        type_name_into(field->ty, fieldty, 256);

        fprintf(stderr, "union initializer field %s has type %s, expected %s\n",
                ast->union_init.field.value.identv.ident, exprty, fieldty);
        ++typecheck->errors;
      }

      ast->ty = resolve_type(typecheck, &union_ty);
      return &ast->ty;
    } break;

    case AST_EXPR_TYPE_VARIABLE: {
      struct scope_entry *entry =
          scope_lookup(typecheck->scope, ast->variable.ident.value.identv.ident, 1);
      if (!entry || !entry->vdecl) {
        fprintf(stderr, "%s not found or not a variable\n", ast->variable.ident.value.identv.ident);
        ++typecheck->errors;
        return &typecheck->error_type;
      }
      ast->ty = resolve_type(typecheck, &entry->vdecl->ty);
      return &ast->ty;
    } break;

    case AST_EXPR_TYPE_ARRAY_INDEX: {
      const char *ident = ast->array_index.ident.value.identv.ident;
      struct scope_entry *entry = scope_lookup(typecheck->scope, ident, 1);
      if (!entry || !entry->vdecl) {
        fprintf(stderr, "%s not found or not a variable\n", ident);
        ++typecheck->errors;
        return &typecheck->error_type;
      }

      if (entry->vdecl->ty.ty != AST_TYPE_ARRAY && entry->vdecl->ty.ty != AST_TYPE_POINTER) {
        char tystr[256];
        type_name_into(&entry->vdecl->ty, tystr, 256);

        fprintf(stderr, "array index %s has type %s, expected an array or pointer type\n", ident,
                tystr);
        ++typecheck->errors;
        return &typecheck->error_type;
      }

      // try to coerce the index to a 32-bit integer
      struct ast_ty *index_ty = typecheck_expr(typecheck, ast->array_index.index);
      if (!index_ty) {
        return NULL;
      }

      struct ast_ty int_ty;
      int_ty.ty = AST_TYPE_INTEGER;
      int_ty.integer.is_signed = 1;
      int_ty.integer.width = 32;
      maybe_implicitly_convert(index_ty, &int_ty);

      if (entry->vdecl->ty.ty == AST_TYPE_ARRAY) {
        ast->ty = resolve_type(typecheck, entry->vdecl->ty.array.element_ty);
      } else {
        // type of expression is the type pointed to by the pointer
        ast->ty = resolve_type(typecheck, ptr_pointee_type(&entry->vdecl->ty));
      }
      return &ast->ty;
    } break;

    case AST_EXPR_TYPE_BINARY: {
      struct ast_ty *lhs = typecheck_expr(typecheck, ast->binary.lhs);
      struct ast_ty *rhs = typecheck_expr(typecheck, ast->binary.rhs);

      if (!lhs || !rhs) {
        return NULL;
      }

      maybe_implicitly_convert(lhs, rhs);
      maybe_implicitly_convert(rhs, lhs);

      if (!same_type(lhs, rhs) && !binary_mismatch_ok(ast->binary.op, lhs, rhs)) {
        char lhsstr[256], rhsstr[256];
        type_name_into(lhs, lhsstr, 256);
        type_name_into(rhs, rhsstr, 256);

        fprintf(stderr, "binary op %s has mismatching lhs type %s, rhs type %s\n",
                ast_binary_op_to_str(ast->binary.op), lhsstr, rhsstr);
        ++typecheck->errors;
        return &typecheck->error_type;
      }

      if (ast_binary_op_conditional(ast->binary.op) || ast_binary_op_logical(ast->binary.op)) {
        // conditionals & logicals both emit 1-bit booleans
        // don't set signed flag - booleans need to zero-extend in conversions, not sign-extend
        ast->ty.ty = AST_TYPE_INTEGER;
        ast->ty.integer.is_signed = 0;
        ast->ty.integer.width = 1;
        return &ast->ty;
      }

      ast->ty = resolve_type(typecheck, lhs);
      return &ast->ty;
    } break;

    case AST_EXPR_TYPE_LOGICAL: {
      struct ast_ty *lhs = typecheck_expr(typecheck, ast->logical.lhs);
      struct ast_ty *rhs = typecheck_expr(typecheck, ast->logical.rhs);

      if (!lhs || !rhs) {
        return NULL;
      }

      // TODO: consider widening/narrowing to make type of lhs == rhs

      if (!same_type(lhs, rhs)) {
        char lhsstr[256], rhsstr[256];
        type_name_into(lhs, lhsstr, 256);
        type_name_into(rhs, rhsstr, 256);

        fprintf(stderr, "logical op %d has mismatching lhs type %s, rhs type %s\n", ast->logical.op,
                lhsstr, rhsstr);
        ++typecheck->errors;
        return &typecheck->error_type;
      }

      // return type of this operation is actually a 1-bit boolean
      ast->ty.ty = AST_TYPE_INTEGER;
      ast->ty.integer.is_signed = 0;
      ast->ty.integer.width = 1;
      ast->ty = resolve_type(typecheck, &ast->ty);
      return &ast->ty;
    } break;

    case AST_EXPR_TYPE_BLOCK: {
      struct ast_ty *ty = typecheck_block(typecheck, &ast->block);
      ast->ty = resolve_type(typecheck, ty);
      return &ast->ty;
    } break;

    case AST_EXPR_TYPE_CALL: {
      struct scope_entry *entry =
          scope_lookup(typecheck->scope, ast->variable.ident.value.identv.ident, 1);
      if (!entry || !entry->fdecl) {
        fprintf(stderr, "%s not found or not a function\n", ast->variable.ident.value.identv.ident);
        ++typecheck->errors;
        return &typecheck->error_type;
      }

      if (!ast->call.args) {
        // no arguments passed
        if (entry->fdecl->num_params > 0) {
          fprintf(stderr, "function %s called with no arguments, expected %zu\n",
                  ast->variable.ident.value.identv.ident, entry->fdecl->num_params);
          ++typecheck->errors;
          return &typecheck->error_type;
          ;
        }
      } else if (entry->fdecl->num_params != ast->call.args->num_elements) {
        if ((entry->fdecl->flags & DECL_FLAG_VARARG) == 0 ||
            (ast->call.args->num_elements < entry->fdecl->num_params)) {
          fprintf(stderr, "function %s called with %zu arguments, expected %zu\n",
                  ast->variable.ident.value.identv.ident, ast->call.args->num_elements,
                  entry->fdecl->num_params);
          ++typecheck->errors;
          return &typecheck->error_type;
          ;
        }
      }

      ast->call.fdecl = entry->fdecl;

      struct ast_expr_list *args = ast->call.args;
      size_t i = 0;
      while (args) {
        struct ast_ty *arg_ty = typecheck_expr(typecheck, args->expr);
        if (!arg_ty) {
          return NULL;
        }

        // check named parameters, don't check varargs (no types to check)
        if (i < entry->fdecl->num_params) {
          maybe_implicitly_convert(arg_ty, &entry->fdecl->params[i]->ty);
          if (!same_type(arg_ty, &entry->fdecl->params[i]->ty)) {
            char tystr[256], expectedstr[256];
            type_name_into(arg_ty, tystr, 256);
            type_name_into(&entry->fdecl->params[i]->ty, expectedstr, 256);

            fprintf(stderr, "function %s argument %zu has type %s, expected %s\n",
                    ast->variable.ident.value.identv.ident, i + 1, tystr, expectedstr);
            ++typecheck->errors;
          }
        }

        args = args->next;
        ++i;
      }

      struct ast_ty resolved = resolve_type(typecheck, &entry->fdecl->retty);
      free_ty(&ast->ty, 0);
      ast->ty = resolved;
      return &ast->ty;
    } break;

    case AST_EXPR_TYPE_DEREF: {
      struct ast_ty *target_ty = typecheck_expr(typecheck, ast->deref.target);
      if (!target_ty) {
        return NULL;
      }

      struct ast_ty *ty = target_ty;
      if (ty->ty == AST_TYPE_POINTER) {
        ty = ptr_pointee_type(ty);
      }

      if (ty->ty != AST_TYPE_FVEC && ty->ty != AST_TYPE_STRUCT && ty->ty != AST_TYPE_MATRIX) {
        char tystr[256];
        type_name_into(ty, tystr, 256);

        fprintf(stderr, "deref %s has type %s, expected a vector or struct type\n",
                ast->variable.ident.value.identv.ident, tystr);
        ++typecheck->errors;
        return &typecheck->error_type;
      }

      size_t max_field = 0;

      if (ty->ty == AST_TYPE_FVEC) {
        int deref = deref_to_index(ast->deref.field.value.identv.ident);
        if (deref < 0) {
          fprintf(stderr, "fvec deref %s has unknown field %s\n",
                  ast->variable.ident.value.identv.ident, ast->deref.field.value.identv.ident);
          ++typecheck->errors;
          return &typecheck->error_type;
          ;
        }
        ast->deref.field_idx = (size_t)deref;
        max_field = ty->fvec.width;

        ast->ty.ty = AST_TYPE_FLOAT;
      } else if (ty->ty == AST_TYPE_STRUCT) {
        struct ast_struct_field *field = ty->structty.fields;
        size_t i = 0;
        while (field) {
          if (strcmp(field->name, ast->deref.field.value.identv.ident) == 0) {
            ast->deref.field_idx = i;
            break;
          }
          field = field->next;
          ++i;
        }

        if (!field) {
          fprintf(stderr, "struct deref %s references unknown field %s\n",
                  ast->variable.ident.value.identv.ident, ast->deref.field.value.identv.ident);
          ++typecheck->errors;
          return &typecheck->error_type;
          ;
        }

        ast->ty = *field->ty;
        max_field = ty->structty.num_fields;
      } else if (ty->ty == AST_TYPE_MATRIX) {
        int deref = deref_to_index(ast->deref.field.value.identv.ident);
        if (deref < 0) {
          fprintf(stderr, "matrix deref %s has unknown field %s\n",
                  ast->variable.ident.value.identv.ident, ast->deref.field.value.identv.ident);
          ++typecheck->errors;
          return &typecheck->error_type;
          ;
        }
        ast->deref.field_idx = (size_t)deref;
        max_field = ty->matrix.rows;

        ast->ty.ty = AST_TYPE_FVEC;
        ast->ty.fvec.width = ty->matrix.cols;
      }

      // can't deref past the width of the vector
      if (ast->deref.field_idx >= max_field) {
        fprintf(stderr, "deref %s has field #%zd, exceeding field count of %zd\n",
                ast->variable.ident.value.identv.ident, ast->deref.field_idx, max_field);
        ++typecheck->errors;
        return &typecheck->error_type;
      }

      ast->ty = resolve_type(typecheck, &ast->ty);
      return &ast->ty;
    }; break;

    case AST_EXPR_TYPE_VOID:
      ast->ty = type_void();
      return &ast->ty;

    case AST_EXPR_TYPE_CAST: {
      struct ast_ty resolved = resolve_type(typecheck, &ast->cast.ty);
      free_ty(&ast->cast.ty, 0);
      ast->cast.ty = resolved;

      struct ast_ty *expr_ty = typecheck_expr(typecheck, ast->cast.expr);
      if (!expr_ty) {
        return NULL;
      }

      if (!can_cast(&ast->cast.ty, expr_ty)) {
        char tystr[256], exprstr[256];
        type_name_into(&ast->cast.ty, tystr, 256);
        type_name_into(expr_ty, exprstr, 256);

        fprintf(stderr, "incompatible cast from %s to %s\n", exprstr, tystr);
        ++typecheck->errors;
        return &typecheck->error_type;
      }

      resolved = resolve_type(typecheck, &ast->cast.ty);
      free_ty(&ast->ty, 0);
      ast->ty = resolved;
      return &ast->ty;
    } break;

    case AST_EXPR_TYPE_IF: {
      struct ast_ty *cond = typecheck_expr(typecheck, ast->if_expr.cond);
      if (!cond) {
        return NULL;
      }

      struct ast_ty *then_ty = typecheck_block(typecheck, &ast->if_expr.then_block);
      if (!then_ty) {
        return NULL;
      }

      if (ast->if_expr.has_else) {
        struct ast_ty *else_ty = typecheck_block(typecheck, &ast->if_expr.else_block);
        if (!else_ty) {
          return NULL;
        }

        maybe_implicitly_convert(else_ty, then_ty);

        if (!same_type(then_ty, else_ty)) {
          char thenstr[256], elsestr[256];
          type_name_into(then_ty, thenstr, 256);
          type_name_into(else_ty, elsestr, 256);

          fprintf(stderr, "if then block has type %s, else block has type %s\n", thenstr, elsestr);
          ++typecheck->errors;
          return &typecheck->error_type;
        }
      }

      if (then_ty->ty != AST_TYPE_VOID && !ast->if_expr.has_else) {
        fprintf(stderr, "an else block is required when if is used as an expression\n");
        ++typecheck->errors;
        return &typecheck->error_type;
      }

      ast->ty = resolve_type(typecheck, then_ty);
      return &ast->ty;
    } break;

    case AST_EXPR_TYPE_ASSIGN: {
      struct ast_ty *lhs_ty = typecheck_expr(typecheck, ast->assign.lhs);
      if (!lhs_ty) {
        return NULL;
      }

      const char *ident = ast_expr_ident(ast->assign.lhs);
      if (!ident) {
        return NULL;  // TODO: this should happen in semantic pass not here
      }

      struct scope_entry *entry = scope_lookup(typecheck->scope, ident, 1);
      if (!entry || !entry->vdecl) {
        fprintf(stderr, "%s not found or not a variable\n", ident);
        ++typecheck->errors;
        return &typecheck->error_type;
      }

      if (!(entry->vdecl->flags & DECL_FLAG_MUT)) {
        fprintf(stderr, "%s is not mutable\n", ident);
        ++typecheck->errors;
        return &typecheck->error_type;
      }

      struct ast_ty *expr_ty = typecheck_expr_with_tbds(typecheck, ast->assign.expr);
      if (!expr_ty) {
        return NULL;
      }

      if (type_is_tbd(&entry->vdecl->ty)) {
        // inferred type
        entry->vdecl->ty = *expr_ty;

        // remove constant flag if it was inferred
        entry->vdecl->ty.flags &= ~TYPE_FLAG_CONSTANT;
      }

      struct ast_ty *desired_ty = &entry->vdecl->ty;

      const char *field_name = NULL;

      if (ast->assign.lhs->type == AST_EXPR_TYPE_DEREF) {
        // all the checks in this block are probably already handled fine by DEREF, but let's make
        // sure

        if (entry->vdecl->ty.ty != AST_TYPE_STRUCT) {
          fprintf(stderr, "in field assignment, lhs %s has non-struct type\n", ident);
          ++typecheck->errors;
          return &typecheck->error_type;
        }

        struct ast_struct_field *field = entry->vdecl->ty.structty.fields;
        while (field) {
          if (strcmp(field->name, ast->assign.lhs->deref.field.value.identv.ident) == 0) {
            field_name = field->name;
            desired_ty = field->ty;
            break;
          }
          field = field->next;
        }

        if (!field) {
          fprintf(stderr, "field %s not found in struct %s\n",
                  ast->assign.lhs->deref.field.value.identv.ident, ident);
          ++typecheck->errors;
          return &typecheck->error_type;
        }
      }

      maybe_implicitly_convert(expr_ty, desired_ty);

      if (!same_type(desired_ty, expr_ty)) {
        char tystr[256], exprstr[256];
        type_name_into(desired_ty, tystr, 256);
        type_name_into(expr_ty, exprstr, 256);

        if (field_name) {
          fprintf(stderr, "field assignment to %s.%s has type %s, expected %s\n", ident, field_name,
                  exprstr, tystr);
        } else {
          fprintf(stderr, "assignment to %s has type %s, expected %s\n", ident, exprstr, tystr);
        }
        ++typecheck->errors;
        return &typecheck->error_type;
      }

      ast->ty = resolve_type(typecheck, expr_ty);
      return &ast->ty;
    } break;

    case AST_EXPR_TYPE_REF: {
      struct ast_expr *expr = ast->ref.expr;

      if (expr->type != AST_EXPR_TYPE_VARIABLE) {
        fprintf(stderr, "ref expression must resolve to an identifier\n");
        ++typecheck->errors;
        return &typecheck->error_type;
      }

      const char *ident = expr->variable.ident.value.identv.ident;

      struct scope_entry *entry = scope_lookup(typecheck->scope, ident, 1);
      if (!entry || !entry->vdecl) {
        fprintf(stderr, "%s not found or not a variable\n", ident);
        ++typecheck->errors;
        return &typecheck->error_type;
      }

      ast->ref.expr->ty.flags |= TYPE_FLAG_REFERENCE;
      struct ast_ty resolved = resolve_type(typecheck, &expr->ty);
      free_ty(&ast->ty, 0);
      ast->ty = ptr_type(resolved);
      return &ast->ty;
    } break;

    case AST_EXPR_TYPE_LOAD: {
      struct ast_expr *expr = ast->load.expr;

      struct ast_ty *expr_ty = typecheck_expr(typecheck, expr);
      if (!expr_ty) {
        return NULL;
      }

      if (expr_ty->ty != AST_TYPE_POINTER) {
        fprintf(stderr, "load expression must resolve to a pointer\n");
        ++typecheck->errors;
        return &typecheck->error_type;
      }

      ast->ty = resolve_type(typecheck, ptr_pointee_type(expr_ty));
      return &ast->ty;
    } break;

    case AST_EXPR_TYPE_UNARY: {
      struct ast_ty *expr_ty = typecheck_expr(typecheck, ast->unary.expr);
      if (!expr_ty) {
        return NULL;
      }

      switch (ast->unary.op) {
        case AST_UNARY_OP_NEG:
          if (expr_ty->ty != AST_TYPE_INTEGER && expr_ty->ty != AST_TYPE_FLOAT) {
            fprintf(stderr, "negation expression must resolve to an integer or float\n");
            ++typecheck->errors;
            return &typecheck->error_type;
            ;
          }

          ast->ty = resolve_type(typecheck, expr_ty);
          return &ast->ty;

        case AST_UNARY_OP_NOT:
          if (expr_ty->ty != AST_TYPE_INTEGER) {
            fprintf(stderr, "not expression must resolve to an integer\n");
            ++typecheck->errors;
            return &typecheck->error_type;
            ;
          }

          ast->ty = resolve_type(typecheck, expr_ty);
          return &ast->ty;

        case AST_UNARY_OP_COMP:
          if (expr_ty->ty != AST_TYPE_INTEGER) {
            fprintf(stderr, "complement expression must resolve to an integer\n");
            ++typecheck->errors;
            return &typecheck->error_type;
            ;
          }

          ast->ty = resolve_type(typecheck, expr_ty);
          return &ast->ty;

        default:
          fprintf(stderr, "unhandled unary op %d\n", ast->unary.op);
          ++typecheck->errors;
          return &typecheck->error_type;
          ;
      }
    } break;

    case AST_EXPR_TYPE_BOOLEAN: {
      struct ast_ty *lhs = typecheck_expr(typecheck, ast->boolean.lhs);
      struct ast_ty *rhs = typecheck_expr(typecheck, ast->boolean.rhs);

      if (!lhs || !rhs) {
        return NULL;
      }

      ast->ty.ty = AST_TYPE_INTEGER;
      ast->ty.integer.is_signed = 0;
      ast->ty.integer.width = 1;
      ast->ty = resolve_type(typecheck, &ast->ty);
      return &ast->ty;
    } break;

    case AST_EXPR_TYPE_MATCH: {
      struct ast_ty *expr_ty = typecheck_expr(typecheck, ast->match.expr);
      if (!expr_ty) {
        return NULL;
      }

      // first pass: check that all arms have the same pattern type, and check their expressions
      struct ast_expr_match_arm *arm = ast->match.arms;
      while (arm) {
        struct ast_ty *pattern_ty =
            typecheck_pattern_match(typecheck, arm->pattern, &arm->pattern->pattern_match, expr_ty);
        if (!pattern_ty) {
          return NULL;
        }

        maybe_implicitly_convert(pattern_ty, expr_ty);

        if (!same_type(pattern_ty, expr_ty)) {
          char wantstr[256], gotstr[256];
          type_name_into(pattern_ty, wantstr, 256);
          type_name_into(expr_ty, gotstr, 256);

          typecheck_diag_expr(typecheck, ast,
                              "match pattern has incorrect type, wanted %s but got %s\n", wantstr,
                              gotstr);
          ++typecheck->errors;
          return &typecheck->error_type;
          ;
        }

        struct scope_entry *inner_var = NULL;

        if (arm->pattern->type == AST_EXPR_TYPE_PATTERN_MATCH &&
            arm->pattern->pattern_match.inner_vdecl) {
          typecheck->scope = enter_scope(typecheck->scope);

          struct scope_entry *entry = calloc(1, sizeof(struct scope_entry));
          entry->vdecl = arm->pattern->pattern_match.inner_vdecl;
          scope_insert(typecheck->scope,
                       arm->pattern->pattern_match.inner_vdecl->ident.value.identv.ident, entry);

          inner_var = entry;
        }

        struct ast_ty *arm_ty = typecheck_expr(typecheck, arm->expr);

        if (inner_var) {
          typecheck->scope = exit_scope(typecheck->scope);
        }

        if (!arm_ty) {
          return NULL;
        }

        arm = arm->next;
      }

      if (!ast->match.otherwise) {
        typecheck_diag_expr(typecheck, ast, "match expression has no otherwise arm\n");
        ++typecheck->errors;
        return &typecheck->error_type;
      }

      struct ast_ty *otherwise_ty = typecheck_expr(typecheck, ast->match.otherwise->expr);
      if (!otherwise_ty) {
        return NULL;
      }

      struct ast_ty *largest_ty = otherwise_ty;

      // second pass: check that all arms have the same type
      arm = ast->match.arms;
      while (arm) {
        struct ast_expr_match_arm *next = arm->next ? arm->next : ast->match.otherwise;
        if (next) {
          if (!maybe_implicitly_convert(&arm->expr->ty, &next->expr->ty)) {
            maybe_implicitly_convert(&next->expr->ty, &arm->expr->ty);
          }

          if (!same_type(&arm->expr->ty, &next->expr->ty)) {
            char armstr[256], nextstr[256];
            type_name_into(&arm->expr->ty, armstr, 256);
            type_name_into(&next->expr->ty, nextstr, 256);

            typecheck_diag_expr(typecheck, ast,
                                "match arm has type %s, next arm has mismatched type %s\n", armstr,
                                nextstr);
            ++typecheck->errors;
            return &typecheck->error_type;
            ;
          }

          if (wider_type(&arm->expr->ty, largest_ty)) {
            largest_ty = &arm->expr->ty;
          }
        }

        arm = arm->next;
      }

      ast->ty = resolve_type(typecheck, largest_ty);
      return &ast->ty;
    } break;

    case AST_EXPR_TYPE_NIL:
      ast->ty.ty = AST_TYPE_NIL;
      return &ast->ty;

    case AST_EXPR_TYPE_ENUM_INIT: {
      struct alias_entry *entry =
          kv_lookup(typecheck->aliases, ast->enum_init.enum_ty_name.value.identv.ident);
      if (!entry) {
        typecheck_diag_expr(typecheck, ast, "enum type %s not found\n",
                            ast->enum_init.enum_ty_name.value.identv.ident);
        return &typecheck->error_type;
      }

      if (entry->ty.ty != AST_TYPE_ENUM) {
        typecheck_diag_expr(typecheck, ast, "type %s is not an enum\n",
                            ast->enum_init.enum_ty_name.value.identv.ident);
        return &typecheck->error_type;
      }

      struct ast_enum_field *field = entry->ty.enumty.fields;
      while (field) {
        if (!strcmp(field->name, ast->enum_init.enum_val_name.value.identv.ident)) {
          break;
        }
        field = field->next;
      }

      if (!field) {
        typecheck_diag_expr(typecheck, ast, "enum field %s not found in enum %s\n",
                            ast->enum_init.enum_val_name.value.identv.ident,
                            ast->enum_init.enum_ty_name.value.identv.ident);
        return &typecheck->error_type;
      }

      if (ast->enum_init.inner) {
        if (!field->has_inner) {
          typecheck_diag_expr(typecheck, ast, "enum field %s does not have an inner\n",
                              field->name);
          return &typecheck->error_type;
        }

        // includes an inner, ensure it matches the enum field's type
        struct ast_ty *inner_ty = typecheck_expr(typecheck, ast->enum_init.inner);
        if (!inner_ty) {
          return NULL;
        }

        maybe_implicitly_convert(inner_ty, &field->inner);

        struct ast_ty resolved = resolve_type(typecheck, &field->inner);
        free_ty(&field->inner, 0);
        field->inner = resolved;

        if (field->inner.ty != AST_TYPE_CUSTOM) {
          // can't check types if the inner is as yet unresolved
          if (!same_type(inner_ty, &field->inner)) {
            char innerstr[256], fieldstr[256];
            type_name_into(inner_ty, innerstr, 256);
            type_name_into(&field->inner, fieldstr, 256);

            typecheck_diag_expr(typecheck, ast,
                                "enum field %s wraps type %s, but was given type %s instead\n",
                                field->name, fieldstr, innerstr);
            return &typecheck->error_type;
          }
        }
      }

      ast->ty = resolve_type(typecheck, &entry->ty);
      return &ast->ty;
    } break;

    case AST_EXPR_TYPE_PATTERN_MATCH: {
      typecheck_diag_expr(typecheck, ast, "typecheck: pattern match without a match expression\n");
    } break;

    default:
      typecheck_diag_expr(typecheck, ast, "typecheck: unhandled expression type %d\n", ast->type);
  }

  // all expressions must resolve to a type
  return &typecheck->void_type;
}

static int binary_mismatch_ok(int op, struct ast_ty *lhs, struct ast_ty *rhs) {
  // float/fvec can mix but only for certain operations
  // e.g. scale, division
  if ((lhs->ty == AST_TYPE_FVEC && rhs->ty == AST_TYPE_FLOAT) ||
      (lhs->ty == AST_TYPE_FLOAT && rhs->ty == AST_TYPE_FVEC)) {
    return op == AST_BINARY_OP_MUL || op == AST_BINARY_OP_DIV || op == AST_BINARY_OP_MOD;
  }

  // pointer arithmetic
  if (lhs->ty == AST_TYPE_POINTER || rhs->ty == AST_TYPE_POINTER) {
    return op == AST_BINARY_OP_ADD || op == AST_BINARY_OP_SUB;
  }

  // matrix math
  if (lhs->ty == AST_TYPE_MATRIX || rhs->ty == AST_TYPE_MATRIX) {
    return check_matrix_binary_op(op, lhs, rhs);
  }

  return 0;
}

static struct ast_ty resolve_type(struct typecheck *typecheck, struct ast_ty *ty) {
  if (ty == &typecheck->void_type) {
    return *ty;
  }

  if (ty->ty == AST_TYPE_POINTER) {
    struct ast_ty new_ty = copy_type(ty);
    struct ast_ty resolved = resolve_type(typecheck, ty->pointer.pointee);
    free_ty(new_ty.pointer.pointee, 0);
    *new_ty.pointer.pointee = resolved;
    return new_ty;
  }

  if (ty->ty == AST_TYPE_ARRAY) {
    struct ast_ty new_ty = copy_type(ty);
    struct ast_ty resolved = resolve_type(typecheck, ty->array.element_ty);
    free_ty(new_ty.array.element_ty, 0);
    *new_ty.array.element_ty = resolved;
    return new_ty;
  }

  if (ty->ty == AST_TYPE_ENUM && ty->enumty.templates) {
    struct ast_ty new_ty = copy_type(ty);

    // can we resolve?
    struct ast_template_ty *template = new_ty.enumty.templates;
    while (template) {
      if (!template->is_resolved) {
        template->resolved = type_tbd();
      }

      template = template->next;
    }

    return new_ty;
  }

  if (ty->ty == AST_TYPE_TEMPLATE) {
    // step 1: resolve the outer type as the main return type
    struct ast_ty result = resolve_type(typecheck, ty->tmpl.outer);
    if (result.ty != AST_TYPE_ENUM) {
      // can't template non-enums
      fprintf(stderr, "template outer type is not an enum\n");
      return type_error();
    }

    // step 2: resolve the inner types into the specialized enum type
    struct ast_enum_field *field = result.enumty.fields;
    while (field) {
      if (field->has_inner && field->inner.ty == AST_TYPE_CUSTOM) {
        // match to the template list
        struct ast_template_ty *inner = result.enumty.templates;
        struct ast_template_ty *inner_specific = ty->tmpl.inners;
        while (inner) {
          if (strcmp(inner->name, field->inner.name) == 0) {
            break;
          }
          inner = inner->next;
          inner_specific = inner_specific->next;
        }

        if (!inner) {
          fprintf(stderr, "template %s not found\n", field->inner.name);
          return type_error();
        }

        if (!inner_specific->is_resolved) {
          fprintf(stderr, "template %s is not resolved\n", field->inner.name);
          return type_error();
        }

        field->inner = resolve_type(typecheck, &inner_specific->resolved);
      }
      field = field->next;
    }

    return result;
  }

  if (ty->ty != AST_TYPE_CUSTOM || ty->custom.is_template) {
    return copy_type(ty);
  }

  struct alias_entry *entry = kv_lookup(typecheck->aliases, ty->name);
  if (!entry) {
    return type_error();
  }

  if (ty->ty == AST_TYPE_CUSTOM && entry->ty.ty == AST_TYPE_CUSTOM) {
    if (!strcmp(ty->name, entry->ty.name)) {
      fprintf(stderr, "alias loop detected for %s\n", ty->name);
      return type_error();
    }
  }

  if (entry->ty.ty == AST_TYPE_CUSTOM) {
    // recurse until we find a non-alias type
    return resolve_type(typecheck, &entry->ty);
  }

  // copy flags from original type (e.g. ptr); don't mutate original type
  struct ast_ty resolved_type = copy_type(&entry->ty);
  resolved_type.flags |= ty->flags;
  resolved_type.flags |= TYPE_FLAG_INDIRECT;

  return resolved_type;
}

static int deref_to_index(const char *deref) {
  if (isdigit(*deref)) {
    // numeric deref
    // TODO: check that endptr is the end of deref; fully consume the string
    return (int)strtol(deref, NULL, 10);
  }

  if (deref[1] == 0) {
    // single character deref
    switch (deref[0]) {
      // XYZW
      case 'x':
      case 'y':
      case 'z':
        return deref[0] - 'x';
      case 'w':
        return 3;

      // RGBA
      case 'r':
        return 0;
      case 'g':
        return 1;
      case 'b':
        return 2;
      case 'a':
        return 3;
    }
  }

  return -1;
}

int maybe_implicitly_convert(struct ast_ty *from, struct ast_ty *to) {
  if (type_is_tbd(to)) {
    *to = *from;
    return 1;
  }

  if (from->ty == AST_TYPE_NIL) {
    // nil can be coerced to any type
    *from = *to;
    return 1;
  }

  if (!compatible_types(from, to)) {
    // no-op
    return 0;
  }

  if (from->ty == AST_TYPE_INTEGER && to->ty == AST_TYPE_INTEGER) {
    if (from->integer.width == to->integer.width) {
      return 0;
    }

    if (from->flags & TYPE_FLAG_CONSTANT && to->flags & TYPE_FLAG_CONSTANT) {
      int conversion = from->integer.width != to->integer.width;

      // swap from/to so the result is the highest width
      if (from->integer.width > to->integer.width) {
        to->integer.width = from->integer.width;
      } else {
        from->integer.width = to->integer.width;
      }

      // TODO: there be some additional checks around signed/unsigned conversion
      // e.g. make sure the conversion doesn't change the sign
      from->integer.is_signed = to->integer.is_signed;

      return conversion;
    }

    // don't propagate constant type in the wrong direction
    if (to->flags & TYPE_FLAG_CONSTANT) {
      return 0;
    }

    // convert the source width to the destinaiton width
    from->integer.width = to->integer.width;
    from->integer.is_signed = to->integer.is_signed;
    return 1;
  } else if (from->ty == AST_TYPE_ENUM && to->ty == AST_TYPE_ENUM) {
    if (!(from->enumty.templates)) {
      // no implicit conversion, source must have templates
      return 0;
    }

    if (strcmp(from->name, to->specialization_of ? to->specialization_of : to->name) != 0) {
      // no implicit conversion, enum name must match
      return 0;
    }

    int coerced = 0;

    // ensure the most specific type is used (e.g. resolved type)
    struct ast_enum_field *from_field = from->enumty.fields;
    struct ast_enum_field *to_field = to->enumty.fields;
    while (from_field && to_field) {
      if (from_field->has_inner && to_field->has_inner) {
        if (from_field->inner.ty == AST_TYPE_CUSTOM && to_field->inner.ty != AST_TYPE_CUSTOM) {
          // bring across the resolved type
          free_ty(&from_field->inner, 0);
          from_field->inner = copy_type(&to_field->inner);
          coerced = 1;
        }
      }

      from_field = from_field->next;
      to_field = to_field->next;
    }

    if (coerced) {
      // copy names and specialization to allow further implicit conversions
      strncpy(from->name, to->name, sizeof(from->name));
      if (to->specialization_of) {
        from->specialization_of = strdup(to->specialization_of);
      }
    }

    return coerced;
  }

  return 0;
}

static void resolve_template_type(struct typecheck *typecheck, struct ast_template_ty *templates,
                                  struct ast_ty *ty) {
  UNUSED(typecheck);

  if (ty->ty != AST_TYPE_CUSTOM) {
    return;
  }

  // match to template types if present
  struct ast_template_ty *template = templates;
  while (template) {
    if (!strcmp(template->name, ty->name)) {
      if (template->is_resolved) {
        free_ty(ty, 0);
        *ty = copy_type(&template->resolved);
      } else {
        ty->custom.is_template = 1;
      }
    }
    template = template->next;
  }
}

static struct ast_ty *typecheck_pattern_match(struct typecheck *typecheck, struct ast_expr *ast,
                                              struct ast_expr_pattern_match *pattern,
                                              struct ast_ty *match_ty) {
  if (ast->type != AST_EXPR_TYPE_PATTERN_MATCH) {
    return typecheck_expr(typecheck, ast);
  }

  if (match_ty->ty != AST_TYPE_ENUM) {
    typecheck_diag_expr(typecheck, ast, "match type is not an enum\n");
    return &typecheck->error_type;
  }

  struct ast_enum_field *field = match_ty->enumty.fields;
  while (field) {
    if (!strcmp(field->name, pattern->name.value.identv.ident)) {
      break;
    }
    field = field->next;
  }

  if (!field) {
    typecheck_diag_expr(typecheck, ast, "enum field %s not found in enum %s\n",
                        pattern->name.value.identv.ident, pattern->enum_name.value.identv.ident);
    return &typecheck->error_type;
  }

  if (pattern->inner_vdecl) {
    pattern->inner_vdecl->ty = resolve_type(typecheck, &field->inner);
  }

  // no need to check inner, it'll become the type of the pattern match in the handler for the
  // match expression
  ast->ty = resolve_type(typecheck, match_ty);
  return &ast->ty;
}

static int check_matrix_binary_op(int op, struct ast_ty *lhs, struct ast_ty *rhs) {
  if (lhs->ty != AST_TYPE_MATRIX && rhs->ty != AST_TYPE_MATRIX) {
    return 0;
  }

  // matrix vs matrix ops
  if (lhs->ty == AST_TYPE_MATRIX && rhs->ty == AST_TYPE_MATRIX) {
    if (op == AST_BINARY_OP_MUL) {
      // # of columns in left must match # of rows in right for multiplication
      return lhs->matrix.cols == rhs->matrix.rows;
    }

    // other ops require the same dimensions
    if (lhs->matrix.cols != rhs->matrix.cols || lhs->matrix.rows != rhs->matrix.rows) {
      return 0;
    }

    // only addition and subtraction are valid for matrices
    return op == AST_BINARY_OP_ADD || op == AST_BINARY_OP_SUB;
  }

  if (lhs->ty == AST_TYPE_MATRIX && rhs->ty == AST_TYPE_FVEC) {
    // fvec must be on the LHS for matrix multiplication
    return 0;
  }

  if (lhs->ty == AST_TYPE_FVEC && rhs->ty == AST_TYPE_MATRIX) {
    if (op != AST_BINARY_OP_MUL) {
      return 0;
    }

    // # of rows must match the width of the vector
    return lhs->matrix.cols == rhs->fvec.width;
  }

  if (lhs->ty != AST_TYPE_MATRIX || rhs->ty != AST_TYPE_MATRIX) {
    // make LHS the matrix type for comparisons
    if (lhs->ty != AST_TYPE_MATRIX) {
      struct ast_ty tmp = *lhs;
      *lhs = *rhs;
      *rhs = tmp;
    }
  }

  if (lhs->ty == AST_TYPE_MATRIX && rhs->ty == AST_TYPE_FLOAT) {
    // matrix scalar multiply is valid
    return op == AST_BINARY_OP_MUL;
  }

  return 0;
}
