start ::= module

module ::= top_decl+

top_decl ::= import
           | cimport
           | foreign_block
           | fn_decl
           | tydecl
           | global_decl

import ::= 'import' STRING ';'
cimport ::= 'cimport' STRING ';'

foreign_block ::= 'foreign' STRING '{' foreign_fn_decl* '}'
foreign_fn_decl ::= fn_header fn_intrinsic? ';'

fn_decl ::= fn_definition
         | fn_forward_decl
         | fn_intrinsic_decl

fn_intrinsic_decl ::= fn_header fn_intrinsic ';'
fn_forward_decl ::= fn_header ';'
fn_definition ::= fn_header block

fn_header ::= visibility? fn_purity 'fn' IDENT '(' params? ')' return_type?
fn_purity ::= 'impure'?
return_type ::= '->' type

fn_intrinsic ::= 'intrinsic' STRING intrinsic_type_list
intrinsic_type_list ::= type (',' type)*

params ::= param (',' param)* (',' '*')?
        | '*'
param ::= type IDENT

tydecl ::= 'type' IDENT ( '=' type_body )? ';'
type_body ::= type
           | struct_decl
           | enum_decl

struct_decl ::= 'struct' '{' struct_field+ '}'
struct_field ::= type IDENT ';'

enum_decl ::= 'enum' enum_generics? '{' enum_variant_list? '}'
enum_generics ::= '<' IDENT (',' IDENT)* '>'
enum_variant_list ::= enum_variant (',' enum_variant)* ','?
enum_variant ::= IDENT ( '(' type ')' )?

global_decl ::= visibility? ( global_data | global_state ) ';'
global_data ::= 'data' global_binding
global_state ::= 'state' global_binding
global_binding ::= type IDENT ( '=' expr )?

visibility ::= 'pub'
mutability ::= 'mut'

block ::= '{' stmt* expr? '}'

stmt ::= stmt_inner? ';'
stmt_inner ::= let_stmt
            | ret_stmt
            | defer_stmt
            | iter_stmt
            | while_stmt
            | break_stmt
            | continue_stmt
            | expr_stmt

let_stmt ::= 'let' mutability? binding
binding ::= inferred_binding | typed_binding

inferred_binding ::= IDENT '=' expr
typed_binding ::= type IDENT '=' expr

ret_stmt ::= 'ret' expr?
defer_stmt ::= 'defer' expr
iter_stmt ::= 'iter' iter_range IDENT block
iter_range ::= expr ':' expr (':' expr)?
while_stmt ::= 'while' expr block
break_stmt ::= 'break'
continue_stmt ::= 'continue'
expr_stmt ::= expr

expr ::= assignment
assignment ::= logic_or ( assignment_operator assignment )?
assignment_operator ::= '=' | ':='

multiplicative ::= unary ( multiplicative_operator unary )*
additive ::= multiplicative ( additive_operator multiplicative )*
shift ::= additive ( shift_operator additive )*
relational ::= shift ( relational_operator shift )*
equality ::= relational ( equality_operator relational )*
bit_and ::= equality ( '&' equality )*
bit_xor ::= bit_and ( '^' bit_and )*
bit_or ::= bit_xor ( '|' bit_xor )*
logic_and ::= bit_or ( '&&' bit_or )*
logic_or ::= logic_and ( '||' logic_and )*

multiplicative_operator ::= '*' | '/' | '%'
additive_operator ::= '+' | '-'
shift_operator ::= '<<' | '>>'
relational_operator ::= '<' | '<=' | '>' | '>='
equality_operator ::= '==' | '!='

unary ::= unary_prefix unary
       | primary postfix_part*
unary_prefix ::= '!' | '-' | '~' | 'load' | 'unbox' | 'ref' | 'box'

postfix_part ::= '(' args? ')'
              | '[' expr ']'
              | '.' IDENT
              | '->' IDENT

args ::= expr (',' expr)*

primary ::= literal
         | enum_variant_literal
         | block
         | '(' expr ')'
         | initializer
         | if_expr
         | match_expr
         | as_expr
         | size_expr
         | 'nil'
         | IDENT

as_expr ::= 'as' '<' type '>' '(' expr ')'

size_expr ::= 'size' size_param
size_param ::= '<' type '>'
            | '(' expr ')'

literal ::= HEX | OCT | BIN | INT | FLOAT | STRING | CHAR | mat_literal | vec_literal

mat_literal ::= 'Mat' '<' mat_inner '>'
mat_inner ::= mat_row+
mat_row ::= vec_literal ','

vec_literal ::= 'Vec' '<' unary vec_literal_tail? '>'
vec_literal_tail ::= ',' unary (',' unary)*

initializer ::= '{' initializer_list '}'
initializer_list ::= expr ','
                   | expr (',' expr)+ ','?

if_expr ::= 'if' expr block ( 'else' ( if_expr | block ) )?

match_expr ::= 'match' expr '{' match_arm+ '}'
match_arm ::= pattern '=>' expr

pattern ::= '_'
         | literal
         | pattern_enum pattern_payload?
pattern_enum ::= IDENT ( '::' IDENT )?
pattern_payload ::= '(' pattern_binding (',' pattern_binding)* ')'
pattern_binding ::= IDENT | '_'

enum_variant_literal ::= IDENT '::' enum_variant_literal_typed? IDENT
enum_variant_literal_typed ::= type_arguments '::'

type_path ::= IDENT '::' type_arguments
type_arguments ::= '<' type (',' type)* '>'

type ::= type_primary type_suffix*
type_primary ::= builtin_type
              | type_path
              | type_cell
              | type_function
              | type_vararg_function
              | IDENT

builtin_type ::= NUMERIC_TYPE | VEC_TYPE | MAT_TYPE | 'float' | 'void' | 'str'

type_cell ::= 'Cell' '<' type '>'

type_function ::= 'Function' type_function_meta
type_vararg_function ::= 'VAFunction' type_function_meta
type_function_meta ::= '<' '(' ( function_type_params | '_' ) ')' '->' type '>'

function_type_params ::= type (',' type)*

type_suffix ::= '*'
             | '^'
             | array_suffix

array_suffix ::= '[' INT ']'

NUMERIC_TYPE ::= /[iu][1-9][0-9]*/
VEC_TYPE ::= /fvec[1-9][0-9]*/
MAT_TYPE ::= /f?mat[1-9][0-9]*x[1-9][0-9]*/
FLOAT ::= '0' '.' DIGIT+ | NONZERO_DIGIT DIGIT* '.' DIGIT+
INT ::= '0' | NONZERO_DIGIT DIGIT*
HEX ::= '0' 'x' HEX_DIGIT+
OCT ::= '0' 'o' OCT_DIGIT+
BIN ::= '0' 'b' BIN_DIGIT+
STRING ::= '"' string_char* '"'
string_char ::= string_escape | string_plain
string_plain ::= /[^"\\]/
string_escape ::= '\\' escaped_char
escaped_char ::= /./
CHAR ::= "'" char_char "'"
char_char ::= char_escape | char_plain
char_plain ::= /[^'\\]/
char_escape ::= '\\' escaped_char
IDENT ::= IDENT_START IDENT_CONT* ( '-' IDENT_CONT+ )*
IDENT_START ::= /[A-Za-z_]/
IDENT_CONT ::= /[A-Za-z0-9_]/
DIGIT ::= /[0-9]/
NONZERO_DIGIT ::= /[1-9]/
HEX_DIGIT ::= /[0-9a-fA-F]/
OCT_DIGIT ::= /[0-7]/
BIN_DIGIT ::= /[0-1]/

WS ::= ( #x20 | #x09 | #x0A | #x0D )+
COMMENT ::= '//' comment_char* line_break?
comment_char ::= /[#x00-#x09#x0B-#x0C#x0E-#x10FFFF]/
ML_COMMENT ::= '/*' ml_comment_char* '*/'
ml_comment_char ::= /[#x00-#x10FFFF]/
line_break ::= #x0D #x0A | #x0A | #x0D
