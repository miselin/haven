start: module

module: top_decl+

top_decl: import
        | cimport
        | foreign_block
        | fn_decl
        | tydecl
        | global_decl

import: "import" STRING ";"
cimport: "cimport" STRING ";"

foreign_block: "foreign" STRING "{" foreign_fn_decl* "}"
foreign_fn_decl: fn_header fn_intrinsic? ";"

fn_decl: fn_definition
       | fn_forward_decl
       | fn_intrinsic_decl

fn_intrinsic_decl: fn_header fn_intrinsic ";"
fn_forward_decl: fn_header ";"
fn_definition: fn_header block

fn_header: visibility? fn_purity "fn" IDENT "(" params? ")" return_type?
fn_purity: "impure"?
return_type: "->" type

fn_intrinsic: "intrinsic" STRING intrinsic_type_list
intrinsic_type_list: type ("," type)*

params: param ("," param)* ("," "*")?
      | "*"
param: type IDENT

tydecl: "type" IDENT ("=" type_body)? ";"
type_body: type
         | struct_decl
         | enum_decl

struct_decl: STRUCT "{" struct_field+ "}"
struct_field: type IDENT ";"

enum_decl: "enum" enum_generics? "{" enum_variant_list? "}"
enum_generics: "<" IDENT ("," IDENT)* ">"
enum_variant_list: enum_variant ("," enum_variant)* (",")?
enum_variant: IDENT ("(" type ")")?

global_decl: visibility? (global_data | global_state) ";"
global_data: "data" global_binding
global_state: "state" global_binding
global_binding: type IDENT ("=" expr)?

visibility: "pub"
mutability: "mut"

block: "{" stmt* expr? "}"

stmt: stmt_inner? ";"
?stmt_inner: let_stmt
           | ret_stmt
           | defer_stmt
           | iter_stmt
           | while_stmt
           | break_stmt
           | continue_stmt
           | expr_stmt

let_stmt: "let" mutability? binding
binding: inferred_binding | typed_binding

inferred_binding: IDENT "=" expr
typed_binding: type IDENT "=" expr

ret_stmt: "ret" expr?
defer_stmt: "defer" expr
iter_stmt: "iter" iter_range IDENT block
iter_range: expr ":" expr (":" expr)?
while_stmt: "while" expr block
break_stmt: "break"
continue_stmt: "continue"
expr_stmt: expr

?expr: assignment
?assignment: logic_or
           | logic_or ("=" | ":=") assignment

?multiplicative.50: unary (("*" | "/" | "%") unary)*
?additive.45: multiplicative (("+" | "-") multiplicative)*
?shift.40: additive (("<<" | ">>") additive)*
?relational.35: shift (("<" | "<=" | ">" | ">=") shift)*
?equality.30: relational (("==" | "!=") relational)*
?bit_and.25: equality ("&" equality)*
?bit_xor.20: bit_and ("^" bit_and)*
?bit_or.15: bit_xor ("|" bit_xor)*
?logic_and.10: bit_or ("&&" bit_or)*
?logic_or.5: logic_and ("||" logic_and)*

?unary: ("!" | "-" | "~") unary
      | "load" unary
      | "unbox" unary
      | "ref" unary
      | "box" unary
      | as
      | size
      | primary postfix_part*

as: "as" "<" type ">" "(" expr ")"

size: "size" size_param
size_param: "<" type ">"
          | "(" expr ")"

postfix_part: "(" args? ")"
            | "[" expr "]"
            | "." IDENT
            | "->" IDENT

args: expr ("," expr)*

?primary: literal
        | enum_variant_literal
        | block
        | "(" expr ")"
        | initializer
        | if_expr
        | match_expr
        | "nil"
        | IDENT

literal: hex_literal
       | octal_literal
       | binary_literal
       | INT
       | FLOAT
       | STRING
       | CHAR
       | mat_literal
       | vec_literal

hex_literal: "0x" HEX
octal_literal: "0o" OCT
binary_literal: "0b" BIN

mat_literal: "Mat" "<" mat_inner ">"
mat_inner: mat_row+ | mat_col+

mat_row: "Row" "<" unary mat_row_tail? ">" ","
mat_row_tail: "," unary ("," unary)*

mat_col: "Col" "<" unary mat_col_tail? ">" ","
mat_col_tail: "," unary ("," unary)*

vec_literal: "Vec" "<" unary vec_literal_tail? ">"
vec_literal_tail: "," unary ("," unary)*

initializer: "{" initializer_list "}"
initializer_list: (expr ",")
                | expr ("," expr)+ ","?

if_expr: "if" expr block ("else" (if_expr | block))?

match_expr: "match" expr "{" match_arm+ "}"
match_arm: pattern "=>" expr

pattern: "_"
       | literal
       | IDENT pattern_payload?
pattern_payload: "(" pattern_binding ("," pattern_binding)* ")"
pattern_binding: IDENT | "_"

enum_variant_literal: IDENT "::" enum_variant_literal_typed? IDENT
enum_variant_literal_typed: type_arguments "::"

type_path: IDENT "::" (type_arguments "::")? IDENT

type_arguments: "<" type ("," type)* (",")? ">"

?type: type_primary type_suffix*
?type_primary: builtin_type
             | type_path
             | type_cell
             | type_function
             | type_vararg_function
             | IDENT // custom type

builtin_type: NUMERIC_TYPE
            | VEC_TYPE
            | MAT_TYPE
            | "float"
            | "void"
            | "str"

type_cell: "Cell" "<" type ">"

type_function: "Function" type_function_meta
type_vararg_function: "VAFunction" type_function_meta
type_function_meta: "<" "(" (function_type_params | "_") ")" "->" type ">"

function_type_params: type ("," type)*

type_suffix: "*"
           | "^"
           | array_suffix

array_suffix: "[" INT "]"

// Priorities selected to ensure these take precedence over IDENT
NUMERIC_TYPE.1: /(i|u)[1-9][0-9]*/
VEC_TYPE.1: /fvec[1-9][0-9]*/
MAT_TYPE.1: /(fmat|mat)[1-9][0-9]*x[1-9][0-9]*/
FLOAT_TYPE.1: "float"
VOID_TYPE.1: "void"
STR_TYPE.1: "str"
STRUCT.2: "struct" // ensure struct is lexed greedily

IDENT.0: /[A-Za-z_][A-Za-z0-9_]*(?:-[A-Za-z0-9_]+)*/
INT: /0|[1-9][0-9]*/
FLOAT: /(?:0|[1-9][0-9]*)\.[0-9]+/
HEX: /[a-fA-F0-9]+/
OCT: /[0-7]+/
BIN: /[0-1]+/
STRING: /"([^"\\]|\\.)*"/
CHAR: /'(.|\\.)'/

%import common.WS
%ignore WS

COMMENT: "//" /[^\n]*/
%ignore COMMENT

ML_COMMENT: /\/\*[\s\S]*?\*\//
%ignore ML_COMMENT
