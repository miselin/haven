start: module

module: top_decl+

top_decl: import
        | cimport
        | foreign_block
        | fn_decl
        | tydecl
        | global_decl

import: "import" STRING ";"
cimport: "cimport" STRING ";"

foreign_block: "foreign" STRING "{" foreign_fn_decl* "}"
foreign_fn_decl: fn_header fn_intrinsic? ";"

fn_decl: fn_header fn_intrinsic? fn_body
fn_body: block | ";"

fn_header: visibility? fn_purity "fn" IDENT "(" params? ")" return_type?
fn_purity: "impure"?
return_type: "->" type

fn_intrinsic: "intrinsic" STRING intrinsic_type_list
intrinsic_type_list: type ("," type)*

params: param ("," param)* ("," "*")?
      | "*"
param: type IDENT

tydecl: "type" IDENT "=" type_body ";"
type_body: type
         | struct_decl
         | enum_decl
         | union_decl

struct_decl: "struct" "{" struct_field+ "}"
struct_field: type IDENT ";"

enum_decl: "enum" enum_generics? "{" enum_variant_list? "}"
enum_generics: "<" IDENT ("," IDENT)* ">"
enum_variant_list: enum_variant ("," enum_variant)* (",")?
enum_variant: IDENT ("(" type ")")?

union_decl: "union" "{" union_field+ "}"
union_field: type IDENT ";"

global_decl: visibility? mutability? type IDENT ("=" expr)? ";"
visibility: "pub"
mutability: "mut"

block: "{" stmt* expr? "}"

stmt: let_stmt
    | ret_stmt
    | defer_stmt
    | iter_stmt
    | while_stmt
    | break_stmt
    | continue_stmt
    | ";"            -> empty_stmt
    | expr_stmt

let_stmt: "let" "mut"? let_binding "=" expr ";"
let_binding: typed_binding | IDENT
typed_binding: type IDENT

ret_stmt: "ret" expr? ";"
defer_stmt: "defer" expr ";"
iter_stmt: "iter" iter_range IDENT block ";"?
iter_range: expr ":" expr (":" expr)?
while_stmt: "while" expr block ";"?
break_stmt: "break" ";"
continue_stmt: "continue" ";"
expr_stmt: expr ";"

?expr: assignment
?assignment: logic_or (("=" | ":=") assignment)?
?logic_or: logic_and ("||" logic_and)*
?logic_and: bit_or ("&&" bit_or)*
?bit_or: bit_xor ("|" bit_xor)*
?bit_xor: bit_and ("^" bit_and)*
?bit_and: equality ("&" equality)*
?equality: relational (("==" | "!=") relational)*
?relational: shift (("<" | "<=" | ">" | ">=") shift)*
?shift: additive (("<<" | ">>") additive)*
?additive: multiplicative (("+" | "-") multiplicative)*
?multiplicative: unary (("*" | "/" | "%") unary)*

?unary: ("!" | "-" | "~") unary
      | "load" unary
      | "unbox" unary
      | "ref" unary
      | "box" unary
      | "store" expr expr
      | "sizeof" "(" (type | expr) ")"
      | "as" type unary
      | postfix

?postfix: primary postfix_part*
postfix_part: "(" args? ")"
            | "[" expr "]"
            | "." IDENT
            | "->" IDENT

args: expr ("," expr)* (",")?

?primary: literal
        | struct_literal
        | union_literal
        | path_ident
        | block
        | "(" expr ")"
        | initializer
        | if_expr
        | match_expr
        | "nil"

literal: float_literal
       | hex_literal
       | octal_literal
       | binary_literal
       | INT
       | STRING
       | CHAR
       | vec_literal
       | mat_literal

float_literal: INT "." FRACTION
hex_literal: "0x" HEX
octal_literal: "0o" OCT
binary_literal: "0b" BIN

vec_literal: "<" expr ("," expr)* (",")? ">"
mat_literal: "<" vec_literal ("," vec_literal)* ">"
initializer: "{" expr "," initializer_tail
initializer_tail: "}"
                | expr ("," expr)* (",")? "}"

struct_literal: "struct" path_ident? "{" struct_literal_args? "}"
struct_literal_args: expr ("," expr)* (",")?

union_literal: "union" path_ident "::" IDENT "(" expr? ")"

if_expr: "if" expr expr ("else" expr)?

match_expr: "match" expr "{" match_arm+ "}"
match_arm: pattern "=>" expr

pattern: "_"
       | literal
       | path_ident pattern_payload?
pattern_payload: "(" pattern_binding ("," pattern_binding)* ")"
pattern_binding: IDENT | "_"

path_ident: IDENT type_arguments? path_ident_segment*
path_ident_segment: "::" IDENT type_arguments?
                  | "::" type_arguments
type_arguments: "<" type ("," type)* (",")? ">"

?type: type_primary type_suffix*
?type_primary: builtin_type
             | path_ident
             | type_cell
             | type_function

builtin_type: NUMERIC_TYPE
            | VEC_TYPE
            | MAT_TYPE
            | FLOAT_TYPE
            | VOID_TYPE
            | STR_TYPE

type_cell: "Cell" "<" type ">"

type_function: "fn" "(" function_type_params? ")" return_type?

function_type_params: type ("," type)* ("," "*")?
                    | "*"

type_suffix: "*"
           | "^"
           | array_suffix

array_suffix: "[" INT "]"

NUMERIC_TYPE: /(i|u)[1-9][0-9]*/
VEC_TYPE: /fvec[1-9][0-9]*/
MAT_TYPE: /(fmat|mat)[1-9][0-9]*x[1-9][0-9]*/
FLOAT_TYPE: "float"
VOID_TYPE: "void"
STR_TYPE: "str"

IDENT: /[A-Za-z_][A-Za-z0-9_]*(?:-[A-Za-z0-9_]+)*/
INT: /0|[1-9][0-9]*/
HEX: /[a-fA-F0-9]+/
OCT: /[0-7]+/
BIN: /[0-1]+/
FRACTION: /[0-9]+/
STRING: /"([^"\\]|\\.)*"/
CHAR: /'(.|\\.)'/

%import common.WS
%ignore WS

COMMENT: "//" /[^\n]*/
%ignore COMMENT

ML_COMMENT: /\/\*[\s\S]*?\*\//
%ignore ML_COMMENT
